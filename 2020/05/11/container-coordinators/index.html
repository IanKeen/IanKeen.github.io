<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Ian Keen"><meta og:site_name="Container Coordinators"><meta og:title="Container Coordinators"><meta og:description=""><meta og:url="https://iankeen.tech"><meta twitter:card="summary"><meta twitter:site="@IanKay"><meta twitter:creator="@IanKay"><meta twitter:title="Container Coordinators"><meta twitter:description=""><title>devbits: random development bits by Ian Keen</title><link rel="stylesheet" href="/Resources/style.css"><link rel="stylesheet" href="/Resources/swift.css"><link rel="shortcut icon" href="/Resources/favicon.ico"></head><body><div id="page-header"><a href="/"><div id="logo" class="wiggle"><p>devbits</p></div></a><div id="links"><div id="me"><a href="/workwithme/index.html">work with me</a><a href="/about/index.html">about</a></div><div id="social"><a href="https://www.twitter.com/IanKay"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tLjEzOSA5LjIzN2MuMjA5IDQuNjE3LTMuMjM0IDkuNzY1LTkuMzMgOS43NjUtMS44NTQgMC0zLjU3OS0uNTQzLTUuMDMyLTEuNDc1IDEuNzQyLjIwNSAzLjQ4LS4yNzggNC44Ni0xLjM1OS0xLjQzNy0uMDI3LTIuNjQ5LS45NzYtMy4wNjYtMi4yOC41MTUuMDk4IDEuMDIxLjA2OSAxLjQ4Mi0uMDU2LTEuNTc5LS4zMTctMi42NjgtMS43MzktMi42MzMtMy4yNi40NDIuMjQ2Ljk0OS4zOTQgMS40ODYuNDExLTEuNDYxLS45NzctMS44NzUtMi45MDctMS4wMTYtNC4zODMgMS42MTkgMS45ODYgNC4wMzggMy4yOTMgNi43NjYgMy40My0uNDc5LTIuMDUzIDEuMDgtNC4wMyAzLjE5OS00LjAzLjk0MyAwIDEuNzk3LjM5OCAyLjM5NSAxLjAzNy43NDgtLjE0NyAxLjQ1MS0uNDIgMi4wODYtLjc5Ni0uMjQ2Ljc2Ny0uNzY2IDEuNDEtMS40NDMgMS44MTYuNjY0LS4wOCAxLjI5Ny0uMjU2IDEuODg1LS41MTctLjQzOS42NTYtLjk5NiAxLjIzNC0xLjYzOSAxLjY5N3oiLz48L3N2Zz4="></a><a href="https://www.github.com/IanKeen"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tNC40NjYgMTkuNTljLS40MDUuMDc4LS41MzQtLjE3MS0uNTM0LS4zODR2LTIuMTk1YzAtLjc0Ny0uMjYyLTEuMjMzLS41NS0xLjQ4MSAxLjc4Mi0uMTk4IDMuNjU0LS44NzUgMy42NTQtMy45NDcgMC0uODc0LS4zMTItMS41ODgtLjgyMy0yLjE0Ny4wODItLjIwMi4zNTYtMS4wMTYtLjA3OS0yLjExNyAwIDAtLjY3MS0uMjE1LTIuMTk4LjgyLS42NC0uMTgtMS4zMjQtLjI2Ny0yLjAwNC0uMjcxLS42OC4wMDMtMS4zNjQuMDkxLTIuMDAzLjI2OS0xLjUyOC0xLjAzNS0yLjItLjgyLTIuMi0uODItLjQzNCAxLjEwMi0uMTYgMS45MTUtLjA3NyAyLjExOC0uNTEyLjU2LS44MjQgMS4yNzMtLjgyNCAyLjE0NyAwIDMuMDY0IDEuODY3IDMuNzUxIDMuNjQ1IDMuOTU0LS4yMjkuMi0uNDM2LjU1Mi0uNTA4IDEuMDctLjQ1Ny4yMDQtMS42MTQuNTU3LTIuMzI4LS42NjYgMCAwLS40MjMtLjc2OC0xLjIyNy0uODI1IDAgMC0uNzgtLjAxLS4wNTUuNDg3IDAgMCAuNTI1LjI0Ni44ODkgMS4xNyAwIDAgLjQ2MyAxLjQyOCAyLjY4OC45NDR2MS40ODljMCAuMjExLS4xMjkuNDU5LS41MjguMzg1LTMuMTgtMS4wNTctNS40NzItNC4wNTYtNS40NzItNy41OSAwLTQuNDE5IDMuNTgyLTggOC04czggMy41ODEgOCA4YzAgMy41MzMtMi4yODkgNi41MzEtNS40NjYgNy41OXoiLz48L3N2Zz4="></a><a href="https://iankeen.tech/atom.xml"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tMTIuODMyIDIwYy0xLjE5NyAwLTIuMTY4LS45NjktMi4xNjgtMi4xNjVzLjk3MS0yLjE2NSAyLjE2OC0yLjE2NSAyLjE2Ny45NjkgMi4xNjcgMi4xNjUtLjk3IDIuMTY1LTIuMTY3IDIuMTY1em01LjE4IDBjLS4wNDEtNC4wMjktMy4zMTQtNy4yOTgtNy4zNDgtNy4zMzl2LTMuMjA3YzUuODE0LjA0MSAxMC41MTggNC43MzkgMTAuNTYxIDEwLjU0NmgtMy4yMTN6bTUuNDQxIDBjLS4wMjEtNy4wNjMtNS43MzYtMTIuNzYxLTEyLjc4OS0xMi43OTJ2LTMuMjA4YzguODMuMDMxIDE1Ljk4IDcuMTc5IDE2IDE2aC0zLjIxMXoiLz48L3N2Zz4="></a></div></div></div><div id="page-title"><h1 class="title plain">Container Coordinators</h1><h2 class="when">11 May 2020</h2><div id="tags"><div class="tag-container"><div class="tag"><a href="/tags/uikit/index.html">UIKit</a></div><div class="tag"><a href="/tags/coordinators/index.html">Coordinators</a></div></div></div><div class="divider"></div></div><div id="page-content"><p>SwiftUI is the new hotness right now, however not everyone is willing or able to go 'all in' on it just yet. For those of us still working away under UIKit, I wanted to share a technique I have been using for a while now to deal with constructing a UI hierarchy and managing navigation.</p><h2>Coordinators</h2><p>You've likely all heard about, and possibly tried, <a href="https://khanlou.com/2015/01/the-coordinator/">Coordinators</a>, a fantastic pattern by <a href="https://twitter.com/khanlou">Soroush Khanlou</a>. I used this pattern myself for a long time. It solved the problem of decoupling navigation from View Controllers so that they could potentially be reused under any number of different scenarios.</p><p>As I used this pattern more and more I would often feel some recurring, nagging, issues. I began to notice things like:</p><ul><li>I was never able to settle on a single abstraction that I liked to use the pattern across any application... there were always subtle differences.</li><li>There was often state to manage with regard to adding and removing children as they execute ("sub" Coordinators).</li><li>This often meant you needed to know when a child Coordinator would be finished so you could clean them up.</li></ul><p>The more I thought about this I began to realize that each Coordinator not only managed a specific <a href="https://developer.apple.com/documentation/uikit/view_controllers">Container Controller</a> but that it's behaviour ended up copying its Containers behaviour. It felt like I was reinventing something that already existed over and over. Navigation based Coordinators ended up mostly pushing things. Tab based Coordinators were mostly managing an array of child Coordinators.</p><p>I was essentially writing Coordinators to do the jobs that the UIKit Containers already do 🤔</p><h2>Container Controllers as Coordinators</h2><p>I decided to try subclassing Containers to act as Coordinators, and once I did something pretty cool happened...</p><ul><li>I no longer had to think about an abstraction: if I wanted a stack based Coordinator I simply subclassed <code>UINavigationController</code>. If I needed a tab based one I could subclass <code>UITabBarController</code> and load it up with my <code>UINavigationController</code> subclasses.</li><li>The state for managing the 'graph' is gone as the subclasses deal with this by design. Now all they contain are the functions for moving between View Controllers or other Containers.</li><li>I don't really care about when a flow is 'complete' anymore. When a ViewController is 'popped' from the stack, for example, it simply cleans itself up.</li></ul><p>I now found I was able to build each Coordinator, in isolation, and not have to think about how it interacted with other Coordinators.</p><p>Consider a simple app with a couple of tabs. A tab with a list of friends and a tab with a list of messages between you and those friends. Let's look at what this might look like using Containers as Coordinators.</p><p>First we have our View Controllers for the lists of friends and messages:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">FriendListViewController</span><span class="none">: </span><span class="type">UITableViewController</span><span class="none"> {
  </span><span class="comment">//..</span><span class="none">
}
</span><span class="keyword">class</span><span class="none"> </span><span class="identifier">MessageListViewController</span><span class="none">: </span><span class="type">UITableViewController</span><span class="none"> {
  </span><span class="comment">//..</span><span class="none">
}
</span></code></pre><p>We know that we will want stack based navigation for each tab so let's build our <code>UINavigationController</code> subclasses for each of them:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">FriendListNavigationController</span><span class="none">: </span><span class="type">UINavigationController</span><span class="none"> {
  </span><span class="keyword">init</span><span class="none">() {
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">nibName</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">bundle</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">FriendListViewController</span><span class="none">()
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="literal">&quot;Friends&quot;</span><span class="none">
    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">viewController</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">false</span><span class="none">)
  }
}

</span><span class="keyword">class</span><span class="none"> </span><span class="identifier">MessageListNavigationController</span><span class="none">: </span><span class="type">UINavigationController</span><span class="none"> {
  </span><span class="keyword">init</span><span class="none">() {
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">nibName</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">bundle</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">MessageListViewController</span><span class="none">()
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="literal">&quot;Messages&quot;</span><span class="none">
    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">viewController</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">false</span><span class="none">)
  }
}
</span></code></pre><p>Finally let's create our <code>UITabBarController</code> subclass to manage these:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">HomeTabController</span><span class="none">: </span><span class="type">UITabBarController</span><span class="none"> {
  </span><span class="keyword">init</span><span class="none">() {
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">nibName</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">bundle</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">users</span><span class="none"> = </span><span class="identifier">FriendListNavigationController</span><span class="none">()
    </span><span class="identifier">users</span><span class="none">.</span><span class="identifier">tabBarItem</span><span class="none"> = .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">title</span><span class="none">: </span><span class="literal">&quot;Users&quot;</span><span class="none">, </span><span class="identifier">image</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">selectedImage</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">messages</span><span class="none"> = </span><span class="identifier">MessageListNavigationController</span><span class="none">()
    </span><span class="identifier">messages</span><span class="none">.</span><span class="identifier">tabBarItem</span><span class="none"> = .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">title</span><span class="none">: </span><span class="literal">&quot;Messages&quot;</span><span class="none">, </span><span class="identifier">image</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">selectedImage</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">users</span><span class="none">, </span><span class="identifier">messages</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">false</span><span class="none">)
  }
}
</span></code></pre><p>If we now compose all of these layers together at run time we end up with an application that looks something like:</p><table><tr><th>Friends Tab</th><th>Messages Tab</th></tr><tr><td><img src="/Resources/container_coordinators/tab1.png"></td><td><img src="/Resources/container_coordinators/tab2.png"></td></tr></table>
<p>Notice that the <code>UINavigationController</code> related properties like <code>title</code> are handled by the <code>UINavigationController</code> subclasses and the <code>UITabBarController</code> related properties like <code>tabItem</code> are handled by the <code>UITabbarController</code> subclasses. This further decouples the individual View Controllers from the context they are being shown in.</p><p>Now that we have decoupled the hierarchy, what about navigation?</p><h2>The Responder Chain</h2><p>Unless you have a lot of experience with building for macOS you may have never <em>explicitly</em> used the <a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Responder Chain</a> on iOS, except perhaps the <code>becomeFirstResponder()</code> function.</p><p>The Responder Chain is based on the class <code>UIResponder</code>. All the common UIKit objects you use inherit from this including <code>UIViewController</code>, <code>UIView</code>, <code>UIWindow</code>, and <code>UIApplication</code>. There are a lot of interesting members on this class but for our needs we are only interested in one:</p><pre><code class="language-swift"><span class="keyword">open</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">next</span><span class="none">: </span><span class="type">UIResponder</span><span class="none">? { </span><span class="keyword">get</span><span class="none"> }
</span></code></pre><p>Why is this one so interesting? Well, if all the items in our view hierarchy implement this it means we basically have a linked list. From any place in the hierarchy we can walk back up the Responder Chain all the way back to the <code>UIApplicationDelegate</code>.</p><p>By default, <code>next</code> will be:</p><ul><li>For <code>UIView</code>s, the <code>superview</code> or the <code>UIViewController</code> if it's the root view.</li><li>For <code>UIViewController</code>s, the containing/presenting view controller or the <code>UIWindow</code> if it's the root View Controller.</li><li>For <code>UIWindow</code>s, the <code>UIApplication</code></li><li>For <code>UIApplication</code>s, the <code>UIApplicationDelegate</code> if it is a <code>UIResponder</code></li></ul><p>We can even alter the chain by overriding <code>next</code> in our subclasses if needed! This gives us an incredibly powerful mechanism, so how can we take advantage?</p><h2>Tapping into UIResponder</h2><p>Now we know <em>what</em> the Responder Chain is; how can we use it for navigation? Well it turns out that we can extend <code>UIResponder</code> with our own custom functions. We can then override these functions elsewhere to perform whatever action is required.</p><p>Knowing this, let's look at how we can navigate to a friend's details when a user taps one from the list. First let's add our <code>UIResponder</code> extension</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">UIResponder</span><span class="none"> {
  </span><span class="keyword">@objc</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">Friend</span><span class="none">) {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">next</span><span class="none"> = </span><span class="identifier">next</span><span class="none"> </span><span class="keyword">else</span><span class="none"> {
      </span><span class="comment">// This gives us a nice piece of diagnostic information in the event</span><span class="none">
      </span><span class="comment">// this action travels along the chain and isn&apos;t handled by anything</span><span class="none">
      </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">print</span><span class="none">(</span><span class="literal">&quot;⚠️ Unhandled action: </span><span class="none">\</span><span class="none">(</span><span class="keyword">#function</span><span class="none">)</span><span class="literal">, Last responder: </span><span class="none">\</span><span class="none">(</span><span class="keyword">self</span><span class="none">)</span><span class="literal">&quot;</span><span class="none">)
    }

    </span><span class="identifier">next</span><span class="none">.</span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="identifier">friend</span><span class="none">)
  }
}
</span></code></pre><p>This will expose a <code>selectedFriend(_:)</code> function to <em>anything</em> on the Responder Chain. Now that we have a way to send the message, let's do so from our friends list:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">FriendListViewController</span><span class="none">: </span><span class="type">UITableViewController</span><span class="none"> {
  </span><span class="comment">//..</span><span class="none">

  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">tableView</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">tableView</span><span class="none">: </span><span class="type">UITableView</span><span class="none">, </span><span class="identifier">didSelectRowAt</span><span class="none"> </span><span class="identifier">indexPath</span><span class="none">: </span><span class="type">IndexPath</span><span class="none">) {
    </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="identifier">data</span><span class="none">[</span><span class="identifier">indexPath</span><span class="none">.</span><span class="identifier">row</span><span class="none">])
  }
}
</span></code></pre><p>Finally we need something to act on this message, so let's do that from our <code>UINavigationController</code> subclass:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">FriendListNavigationController</span><span class="none">: </span><span class="type">UINavigationController</span><span class="none"> {
  </span><span class="comment">//..</span><span class="none">

  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">Friend</span><span class="none">) {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">FriendDetailsViewController</span><span class="none">(</span><span class="identifier">friend</span><span class="none">: </span><span class="identifier">friend</span><span class="none">)
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="identifier">friend</span><span class="none">.</span><span class="identifier">name</span><span class="none">
    </span><span class="identifier">pushViewController</span><span class="none">(</span><span class="identifier">viewController</span><span class="none">, </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">true</span><span class="none">)
  }
}
</span></code></pre><p>And that's it! Our <code>FriendListViewController</code> sends a message out that a certain friend needs to be shown and nothing more. The message travels along the responder chain until it hits our <code>UINavigationController</code> subclass that contains the override. Our subclass then constructs the appropriate View Controller and pushes it on to the stack.</p><p>We have performed all the work of a Coordinator without re-inventing the wheel.</p><h2>Reusing View Controllers</h2><p>After putting in the work to decouple our View Controllers, how we can leverage this new pattern in our app? Let's look at how we might reuse our friends list to select a friend to use when creating a new message.</p><p>You can think of the Containers as the things that provide <em>context</em> or <em>meaning</em> to a View Controllers actions. Our existing <code>FriendListNavigationController</code> translates our <code>selectedFriend</code> action into showing a friends details on the current stack. The context here being the 'friends tab'.</p><p>For this feature we have a new context, so let's create a new Container to deal with it:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">NewMessageNavigationController</span><span class="none">: </span><span class="type">UINavigationController</span><span class="none"> {
  </span><span class="keyword">init</span><span class="none">() {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">FriendListViewController</span><span class="none">()
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="literal">&quot;Select Recipient&quot;</span><span class="none">
    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">viewController</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">false</span><span class="none">)
  }

  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">Friend</span><span class="none">) {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">MessageComposerViewController</span><span class="none">(</span><span class="identifier">recipient</span><span class="none">: </span><span class="identifier">friend</span><span class="none">)
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="identifier">friend</span><span class="none">.</span><span class="identifier">name</span><span class="none">
    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">viewController</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">true</span><span class="none">)
  }
}
</span></code></pre><p>So within this Container we start by showing the friends list, however this time when the user selects someone we will reset the stack to show the composer with the selected friend. We have used our existing friends list in a new context with very little code.</p><p>The only thing left to do is update our existing <code>MessageListNavigationController</code> Container to launch this new one:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">MessageListNavigationController</span><span class="none">: </span><span class="type">UINavigationController</span><span class="none"> {
  </span><span class="keyword">init</span><span class="none">() {
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">nibName</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">bundle</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewController</span><span class="none"> = </span><span class="identifier">MessageListViewController</span><span class="none">()
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">title</span><span class="none"> = </span><span class="literal">&quot;Messages&quot;</span><span class="none">
    </span><span class="identifier">viewController</span><span class="none">.</span><span class="identifier">navigationItem</span><span class="none">.</span><span class="identifier">rightBarButtonItem</span><span class="none"> = .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">title</span><span class="none">: </span><span class="literal">&quot;New&quot;</span><span class="none">, </span><span class="identifier">style</span><span class="none">: .</span><span class="identifier">plain</span><span class="none">, </span><span class="identifier">target</span><span class="none">: </span><span class="keyword">self</span><span class="none">, </span><span class="identifier">action</span><span class="none">: </span><span class="keyword">#selector</span><span class="none">(</span><span class="identifier">composeNewMessage</span><span class="none">))
    </span><span class="identifier">setViewControllers</span><span class="none">([</span><span class="identifier">viewController</span><span class="none">], </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">false</span><span class="none">)
  }

  </span><span class="comment">//..</span><span class="none">

  </span><span class="keyword">@objc</span><span class="none"> </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">composeNewMessage</span><span class="none">() {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">container</span><span class="none"> = </span><span class="identifier">NewMessageNavigationController</span><span class="none">()
    </span><span class="identifier">present</span><span class="none">(</span><span class="identifier">container</span><span class="none">, </span><span class="identifier">animated</span><span class="none">: </span><span class="keyword">true</span><span class="none">, </span><span class="identifier">completion</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)
  }
}
</span></code></pre><p>We have updated the existing Container to attach a navigation item that launches our new message composer Container. Notice that the View Controllers are still bissfully unaware of how they are being used. It is the Containers that contain the details about how they all come together.</p><h2>Other interesting uses</h2><p>There are a few other interesting things the Responder Chain allows us to do.</p><h3>UIViews</h3><p>The fact that smaller components like <code>UIView</code> are <code>UIResponder</code>s means they can also participate in both sending and acting on our custom actions. A <code>UITableViewCell</code> subclass, for example, could call our <code>selectedFriend</code> action rather than the View Controller.</p><h3>Error Handling</h3><p>We could also use this as a way to unify error handling. For example you might consider an extension like:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">UIResponder</span><span class="none"> {
  </span><span class="keyword">@objc</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">handleError</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">error</span><span class="none">: </span><span class="type">Error</span><span class="none">) {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">next</span><span class="none"> = </span><span class="identifier">next</span><span class="none"> </span><span class="keyword">else</span><span class="none"> {
      </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">print</span><span class="none">(</span><span class="literal">&quot;⚠️ Unhandled action: </span><span class="none">\</span><span class="none">(</span><span class="keyword">#function</span><span class="none">)</span><span class="literal">, Last responder: </span><span class="none">\</span><span class="none">(</span><span class="keyword">self</span><span class="none">)</span><span class="literal">&quot;</span><span class="none">)
    }

    </span><span class="identifier">next</span><span class="none">.</span><span class="identifier">handleError</span><span class="none">(</span><span class="identifier">error</span><span class="none">)
  }
}
</span></code></pre><p>Using this you can propagate errors from anywhere in your hierarchy back to a single place, like your <code>UIWindow</code>. Remember, the <code>UIWindow</code> can be a custom subclass just like your other Containers. You can present a generic error alert from there by overriding <code>handleError</code>.</p><h3>IBAction</h3><p>You can also add <code>@IBAction</code> to your <code>UIResponder</code> extensions; doing this will allow you to call them with <code>UIButton</code> taps with no code at all.</p><h3>Pay it forward!</h3><p>Finally don't forget you are dealing with a linked list! Just because you override one of these custom actions doesn't mean you have to end the chain. You might want to update your UI based on the fact that an error occured but not mess with the default handling you have in your <code>UIWindow</code> i.e.:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">MyViewController</span><span class="none">: </span><span class="type">UIViewController</span><span class="none"> {
  </span><span class="comment">//..</span><span class="none">

  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">handleError</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">error</span><span class="none">: </span><span class="type">Error</span><span class="none">) {
    </span><span class="comment">// do something with this controllers appearance</span><span class="none">

    </span><span class="identifier">next</span><span class="none">?.</span><span class="identifier">handleError</span><span class="none">(</span><span class="identifier">error</span><span class="none">) </span><span class="comment">// pass the message along!</span><span class="none">
  }
}
</span></code></pre><h2>Caveats</h2><p>There are a few things you need to know if you would like to give this pattern a try.</p><h3>Swift</h3><p>This is an Objective-C mechanism (You may have noticed the <code>@objc</code> on our <code>UIResponder</code> extensions) and as such pure Swift code is not 'visible'. This means that, by default, you cannot pass along things like structs. To work around this we can box our Swift value in an Objective-C compatible object:</p><pre><code class="language-swift"><span class="keyword">public</span><span class="none"> </span><span class="keyword">class</span><span class="none"> </span><span class="identifier">ResponderBox</span><span class="none">: </span><span class="type">NSObject</span><span class="none"> {
  </span><span class="keyword">@nonobjc</span><span class="none"> </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="keyword">Any</span><span class="none">

  </span><span class="keyword">@nonobjc</span><span class="none"> </span><span class="keyword">public</span><span class="none"> </span><span class="keyword">init</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="type">T</span><span class="none">) {
    </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">value</span><span class="none"> = </span><span class="identifier">value</span><span class="none">
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">()
  }

  </span><span class="keyword">@nonobjc</span><span class="none"> </span><span class="keyword">public</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none">: </span><span class="type">T</span><span class="none">.</span><span class="identifier">Type</span><span class="none"> = </span><span class="identifier">T</span><span class="none">.</span><span class="keyword">self</span><span class="none">) -&gt; </span><span class="type">T</span><span class="none"> {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none"> = </span><span class="identifier">value</span><span class="none"> </span><span class="keyword">as</span><span class="none">? </span><span class="type">T</span><span class="none"> </span><span class="keyword">else</span><span class="none"> {
      </span><span class="identifier">fatalError</span><span class="none">(</span><span class="literal">&quot;Invalid value. Expected </span><span class="none">\</span><span class="none">(</span><span class="identifier">T</span><span class="none">.</span><span class="keyword">self</span><span class="none">)</span><span class="literal">, found </span><span class="none">\</span><span class="none">(</span><span class="identifier">type</span><span class="none">(</span><span class="identifier">of</span><span class="none">: </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">value</span><span class="none">)</span><span class="none">)</span><span class="literal">&quot;</span><span class="none">)
    }

    </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">value</span><span class="none">
  }
}
</span></code></pre><p>The unfortunate downside is that you'll need two <code>UIResponder</code> functions to make this work, taking our <code>selectedFriend</code> example we would need to update it to be:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">UIResponder</span><span class="none"> {
  </span><span class="keyword">@objc</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">ResponderBox</span><span class="none">) {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">next</span><span class="none"> = </span><span class="identifier">next</span><span class="none"> </span><span class="keyword">else</span><span class="none"> {
      </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">print</span><span class="none">(</span><span class="literal">&quot;⚠️ Unhandled action: </span><span class="none">\</span><span class="none">(</span><span class="keyword">#function</span><span class="none">)</span><span class="literal">, Last responder: </span><span class="none">\</span><span class="none">(</span><span class="keyword">self</span><span class="none">)</span><span class="literal">&quot;</span><span class="none">)
    }

    </span><span class="identifier">next</span><span class="none">.</span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="identifier">friend</span><span class="none">)
  }
  </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">Friend</span><span class="none">) {
    </span><span class="identifier">selectedFriend</span><span class="none">(.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">friend</span><span class="none">))
  }
}
</span></code></pre><p>For the objects sending the action nothing changes. They can still call <code>selectedFriend(someFriendStruct)</code>. This function will then box up the struct and call out to the Objective-C compatible version.</p><p>For the objects wanting to act on this they would instead now override the <code>ResponderBox</code> version and extract the underlying struct with code like:</p><pre><code class="language-swift"><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">selectedFriend</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">ResponderBox</span><span class="none">) {
  </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">friend</span><span class="none">: </span><span class="type">Friend</span><span class="none"> = </span><span class="identifier">friend</span><span class="none">.</span><span class="identifier">value</span><span class="none">()

  </span><span class="comment">// use friend struct</span><span class="none">
}
</span></code></pre><p>This is a small inconveience, however the good news is you can't really mess this up. For sending it doesn't matter if you accidentally called the <code>ResponderBox</code> version as they both result in the action being sent along the Responder Chain. As for the overrides, you can only override the <code>ResponderBox</code> version thanks to the <code>@objc</code> annotation. If you tried to override the struct version the compiler would give you an error.</p><h3>Modals</h3><p>In the same way I only move forward using the Containers, I also only move backwards using them. One of the rules I follow is that "the Container that presented something should also dismiss it". However iOS throws a spanner in that by default because regardless of what does the presenting, the window's <code>rootViewController</code> is the value returned by the presented items <code>next</code> value.</p><p>What this means in our example is; Our presented <code>NewMessageNavigationController</code> would return the <code>HomeTabController</code> as its <code>next</code> responder instead of the <code>MessageListNavigationController</code> that presented it.</p><p>Luckily we can work around this also using <a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html">View Controller Containment</a>:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">ResponderController</span><span class="none">: </span><span class="type">UIViewController</span><span class="none"> {
  </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">nextOverride</span><span class="none">: </span><span class="type">UIResponder</span><span class="none">
  </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">child</span><span class="none">: </span><span class="type">UIViewController</span><span class="none">

  </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">containing</span><span class="none">: </span><span class="type">UIViewController</span><span class="none">, </span><span class="identifier">nextResponder</span><span class="none">: </span><span class="type">UIResponder</span><span class="none">) {
    </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">nextOverride</span><span class="none"> = </span><span class="identifier">nextResponder</span><span class="none">
    </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">child</span><span class="none"> = </span><span class="identifier">containing</span><span class="none">
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">nibName</span><span class="none">: </span><span class="keyword">nil</span><span class="none">, </span><span class="identifier">bundle</span><span class="none">: </span><span class="keyword">nil</span><span class="none">)
  }
  </span><span class="keyword">required</span><span class="none"> </span><span class="keyword">init</span><span class="none">?(</span><span class="identifier">coder</span><span class="none">: </span><span class="type">NSCoder</span><span class="none">) {
    </span><span class="identifier">fatalError</span><span class="none">(</span><span class="literal">&quot;init(coder:) has not been implemented&quot;</span><span class="none">)
  }

  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">viewDidLoad</span><span class="none">() {
    </span><span class="keyword">super</span><span class="none">.</span><span class="identifier">viewDidLoad</span><span class="none">()
    </span><span class="identifier">addChild</span><span class="none">(</span><span class="identifier">child</span><span class="none">)
    </span><span class="identifier">view</span><span class="none">.</span><span class="identifier">addSubview</span><span class="none">(</span><span class="identifier">child</span><span class="none">.</span><span class="identifier">view</span><span class="none">)

    </span><span class="identifier">child</span><span class="none">.</span><span class="identifier">view</span><span class="none">.</span><span class="identifier">frame</span><span class="none"> = </span><span class="identifier">view</span><span class="none">.</span><span class="identifier">bounds</span><span class="none">
    </span><span class="identifier">child</span><span class="none">.</span><span class="identifier">view</span><span class="none">.</span><span class="identifier">autoresizingMask</span><span class="none"> = [.</span><span class="identifier">flexibleWidth</span><span class="none">, .</span><span class="identifier">flexibleHeight</span><span class="none">]

    </span><span class="identifier">child</span><span class="none">.</span><span class="identifier">didMove</span><span class="none">(</span><span class="identifier">toParent</span><span class="none">: </span><span class="keyword">self</span><span class="none">)
  }
  </span><span class="keyword">override</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">next</span><span class="none">: </span><span class="type">UIResponder</span><span class="none">? {
    </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">nextOverride</span><span class="none">
  }
}

</span><span class="keyword">extension</span><span class="none"> </span><span class="type">UIViewController</span><span class="none"> {
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">presentModal</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">viewControllerToPresent</span><span class="none">: </span><span class="type">UIViewController</span><span class="none">, </span><span class="identifier">animated</span><span class="none"> </span><span class="identifier">flag</span><span class="none">: </span><span class="type">Bool</span><span class="none">, </span><span class="identifier">completion</span><span class="none">: (() -&gt; </span><span class="type">Void</span><span class="none">)? = </span><span class="keyword">nil</span><span class="none">) {
        </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">wrapper</span><span class="none"> = </span><span class="identifier">ResponderController</span><span class="none">(</span><span class="identifier">containing</span><span class="none">: </span><span class="identifier">viewControllerToPresent</span><span class="none">, </span><span class="identifier">nextResponder</span><span class="none">: </span><span class="keyword">self</span><span class="none">)
        </span><span class="identifier">present</span><span class="none">(</span><span class="identifier">wrapper</span><span class="none">, </span><span class="identifier">animated</span><span class="none">: </span><span class="identifier">flag</span><span class="none">, </span><span class="identifier">completion</span><span class="none">: </span><span class="identifier">completion</span><span class="none">)
    }
}
</span></code></pre><p>By overriding <code>next</code> we can maintain a Responder Chain that matches how we actually construct the UI hierarchy. All you need to do is use <code>presentModal(_:animated:completion:)</code> instead of the usual <code>present(_:animated:completion:)</code> function.</p><h2>Recap</h2><p>If you made it this far you probably have the idea but just to recap the rules I like to use when working with this pattern:</p><ul><li>Only Containers perform transitions; this includes push/pop, present/dismiss.</li><li>Containers configure properties on a View Controller relevant to their duties; this includes properties like <code>title</code>, <code>navigationItem</code>s and <code>tabBarItem</code>s</li></ul><p>Much like the more common Coordinator pattern this certainly isn't a silver bullet. However I have had really good success using it a number of apps so I'd love to hear your feedback if you decide to try it. There are some quirks but overall I find it easier to <em>lean into</em> UIKit rather than try to fight it.</p></div><div id="page-footer"><div class="divider"></div><p>(c) Ian Keen</p></div></body></html>