<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content=""><meta name="author" content="Ian Keen"><meta og:site_name="The missing Combine input type"><meta og:title="The missing Combine input type"><meta og:description=""><meta og:url="https://iankeen.tech"><meta twitter:card="summary"><meta twitter:site="@IanKay"><meta twitter:creator="@IanKay"><meta twitter:title="The missing Combine input type"><meta twitter:description=""><title>devbits: random development bits by Ian Keen</title><link rel="stylesheet" href="/Resources/style.css"><link rel="stylesheet" href="/Resources/swift.css"><link rel="shortcut icon" href="/Resources/favicon.ico"></head><body><div id="page-header"><a href="/"><div id="logo" class="wiggle"><p>devbits</p></div></a><div id="links"><div id="me"><a href="/workwithme/index.html">work with me</a><a href="/about/index.html">about</a></div><div id="social"><a href="https://www.twitter.com/IanKay"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tLjEzOSA5LjIzN2MuMjA5IDQuNjE3LTMuMjM0IDkuNzY1LTkuMzMgOS43NjUtMS44NTQgMC0zLjU3OS0uNTQzLTUuMDMyLTEuNDc1IDEuNzQyLjIwNSAzLjQ4LS4yNzggNC44Ni0xLjM1OS0xLjQzNy0uMDI3LTIuNjQ5LS45NzYtMy4wNjYtMi4yOC41MTUuMDk4IDEuMDIxLjA2OSAxLjQ4Mi0uMDU2LTEuNTc5LS4zMTctMi42NjgtMS43MzktMi42MzMtMy4yNi40NDIuMjQ2Ljk0OS4zOTQgMS40ODYuNDExLTEuNDYxLS45NzctMS44NzUtMi45MDctMS4wMTYtNC4zODMgMS42MTkgMS45ODYgNC4wMzggMy4yOTMgNi43NjYgMy40My0uNDc5LTIuMDUzIDEuMDgtNC4wMyAzLjE5OS00LjAzLjk0MyAwIDEuNzk3LjM5OCAyLjM5NSAxLjAzNy43NDgtLjE0NyAxLjQ1MS0uNDIgMi4wODYtLjc5Ni0uMjQ2Ljc2Ny0uNzY2IDEuNDEtMS40NDMgMS44MTYuNjY0LS4wOCAxLjI5Ny0uMjU2IDEuODg1LS41MTctLjQzOS42NTYtLjk5NiAxLjIzNC0xLjYzOSAxLjY5N3oiLz48L3N2Zz4="></a><a href="https://www.github.com/IanKeen"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tNC40NjYgMTkuNTljLS40MDUuMDc4LS41MzQtLjE3MS0uNTM0LS4zODR2LTIuMTk1YzAtLjc0Ny0uMjYyLTEuMjMzLS41NS0xLjQ4MSAxLjc4Mi0uMTk4IDMuNjU0LS44NzUgMy42NTQtMy45NDcgMC0uODc0LS4zMTItMS41ODgtLjgyMy0yLjE0Ny4wODItLjIwMi4zNTYtMS4wMTYtLjA3OS0yLjExNyAwIDAtLjY3MS0uMjE1LTIuMTk4LjgyLS42NC0uMTgtMS4zMjQtLjI2Ny0yLjAwNC0uMjcxLS42OC4wMDMtMS4zNjQuMDkxLTIuMDAzLjI2OS0xLjUyOC0xLjAzNS0yLjItLjgyLTIuMi0uODItLjQzNCAxLjEwMi0uMTYgMS45MTUtLjA3NyAyLjExOC0uNTEyLjU2LS44MjQgMS4yNzMtLjgyNCAyLjE0NyAwIDMuMDY0IDEuODY3IDMuNzUxIDMuNjQ1IDMuOTU0LS4yMjkuMi0uNDM2LjU1Mi0uNTA4IDEuMDctLjQ1Ny4yMDQtMS42MTQuNTU3LTIuMzI4LS42NjYgMCAwLS40MjMtLjc2OC0xLjIyNy0uODI1IDAgMC0uNzgtLjAxLS4wNTUuNDg3IDAgMCAuNTI1LjI0Ni44ODkgMS4xNyAwIDAgLjQ2MyAxLjQyOCAyLjY4OC45NDR2MS40ODljMCAuMjExLS4xMjkuNDU5LS41MjguMzg1LTMuMTgtMS4wNTctNS40NzItNC4wNTYtNS40NzItNy41OSAwLTQuNDE5IDMuNTgyLTggOC04czggMy41ODEgOCA4YzAgMy41MzMtMi4yODkgNi41MzEtNS40NjYgNy41OXoiLz48L3N2Zz4="></a><a href="https://iankeen.tech/feed.rss"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tMTIuODMyIDIwYy0xLjE5NyAwLTIuMTY4LS45NjktMi4xNjgtMi4xNjVzLjk3MS0yLjE2NSAyLjE2OC0yLjE2NSAyLjE2Ny45NjkgMi4xNjcgMi4xNjUtLjk3IDIuMTY1LTIuMTY3IDIuMTY1em01LjE4IDBjLS4wNDEtNC4wMjktMy4zMTQtNy4yOTgtNy4zNDgtNy4zMzl2LTMuMjA3YzUuODE0LjA0MSAxMC41MTggNC43MzkgMTAuNTYxIDEwLjU0NmgtMy4yMTN6bTUuNDQxIDBjLS4wMjEtNy4wNjMtNS43MzYtMTIuNzYxLTEyLjc4OS0xMi43OTJ2LTMuMjA4YzguODMuMDMxIDE1Ljk4IDcuMTc5IDE2IDE2aC0zLjIxMXoiLz48L3N2Zz4="></a></div></div></div><div id="page-title"><h1 class="title plain">The missing Combine input type</h1><h2 class="when">03 Aug 2020</h2><div id="tags"><div class="tag-container"><div class="tag"><a href="/tags/reactiveprogramming/index.html">ReactiveProgramming</a></div><div class="tag"><a href="/tags/combine/index.html">Combine</a></div><div class="tag"><a href="/tags/mvvm/index.html">MVVM</a></div></div></div><div class="divider"></div></div><div id="page-content"><p>Like most people I have been tinkering with SwiftUI and Combine lately. Mostly using the MVVM pattern since that's what I know best.One thing I miss from RxSwift that Combine doesn't seem to have is a dedicated <em>input only</em> type.In RxSwift there is a protocol called <code>Observer</code> with a provided concrete type of <code>AnyObserver<T></code>.An <code>Observer</code> only exposes ways to send values <em>in</em> but not subscribe to those changes elsewhere.</p><p>So why would this be useful? Well I'm a bit of a stickler for encapsulation.When I'm building, but more importantly debugging, my view models I like to know how data is flowing through them.With strict separation between inputs and outputs I know that any side effects are <em>only</em> triggered as a result of values coming out of the outputs.Likewise I also know that the only thing that could trigger those outputs are the <em>inputs</em> and reacting to the inputs is <em>only</em> able to happenfrom within the view model. This separation makes reasoning about the flow of data <em>much</em> easier, at least for me.</p><p>To dig into this concept, let's take a look at an example view model for authenticating a user:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="comment">//..</span><span class="none">

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="comment">//...</span><span class="none">
    }
}
</span></code></pre><h2>Outputs</h2><p>To represent outputs Combine gives us a <code>Publisher</code> type. We can subscribe to them and use them to make our apps do things.At the end of a <code>Publisher</code> you will eventually find one or more <code>.sink { ... }</code> calls, these are where our side effects live.This includes things like updating the UI or saving information to a database.</p><p>Let's add an output we can use to perform a side effect based on the success or failure of an authentication attempt</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="comment">//...</span><span class="none">
    }
}
</span></code></pre><p>Here we have <code>signInResult</code> using the <code>Result</code> type as its output. When authentication is successful it will emit a <code>.success(Token)</code> value,when it fails it will output a <code>.failure(Error)</code> value.</p><p>So how do we go about <em>triggering</em> the work and eventually get a value from this output? We need an input!</p><h2>Inputsâ€¦ ?</h2><p>But didn't we already decide Combine doesn't have any input types? It <em>does</em> have ways to model inputs, they just come with some baggage.</p><p>The types Combine gives us to send values are called <code>Subject</code>s. <em>But</em>, they are <em>both</em> input <em>and</em> output (<code>Publisher</code>).This means that while we can use them to trigger our authentication attempt we need to be careful about how we use them if we care about encapsulation.</p><p>Let's introduce a <code>Subject</code> and get our view model actually doing something:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signIn</span><span class="none"> = </span><span class="identifier">PassthroughSubject</span><span class="none">&lt;(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">), </span><span class="type">Never</span><span class="none">&gt;()

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="identifier">signInResult</span><span class="none"> = </span><span class="identifier">signIn</span><span class="none">
            .</span><span class="identifier">flatMap</span><span class="none"> { </span><span class="identifier">input</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">API</span><span class="none">
                    .</span><span class="identifier">authenticate</span><span class="none">(</span><span class="identifier">input</span><span class="none">.</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">input</span><span class="none">.</span><span class="identifier">password</span><span class="none">)
                    .</span><span class="identifier">materialize</span><span class="none">()
            }
            .</span><span class="identifier">eraseToAnyPublisher</span><span class="none">()
    }
}
</span></code></pre><p>A <code>PassthroughSubject</code> does exactly what it  says on the label.  It <em>passes</em> values <em>through</em> that it receives via it's <code>send</code> function fulfilling its function as an <em>input</em>. It then uses those values as the source for its function as a <code>Publisher</code>, or <em>output</em>.</p><p>Now we have defined an input we can use it to attempt to authenticate and, finally, emit the result through our output. Let's take a look at what some code using our view model might look like:</p><pre><code class="language-swift"><span class="keyword">let</span><span class="none"> </span><span class="identifier">viewModel</span><span class="none"> = </span><span class="identifier">AuthViewModel</span><span class="none">()

</span><span class="identifier">viewModel</span><span class="none">
    .</span><span class="identifier">signInResult</span><span class="none">
    .</span><span class="identifier">sink</span><span class="none"> { </span><span class="identifier">result</span><span class="none"> </span><span class="keyword">in</span><span class="none">
        </span><span class="identifier">print</span><span class="none">(</span><span class="identifier">result</span><span class="none">) </span><span class="comment">// output: success(Token(value: &quot;foobar&quot;))</span><span class="none">
    }
    .</span><span class="identifier">store</span><span class="none">(</span><span class="identifier">in</span><span class="none">: &amp;</span><span class="identifier">cancellables</span><span class="none">)

</span><span class="identifier">viewModel</span><span class="none">.</span><span class="identifier">signIn</span><span class="none">.</span><span class="identifier">send</span><span class="none">((</span><span class="identifier">username</span><span class="none">: </span><span class="literal">&quot;iankeen&quot;</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="literal">&quot;super_secret_password&quot;</span><span class="none">)) </span><span class="comment">// input</span><span class="none">
</span></code></pre><p>Not bad, however remember <code>Subject</code>s are both input <em>and</em> output. This means we have also left the door open for code like this:</p><pre><code class="language-swift"><span class="identifier">viewModel</span><span class="none">
    .</span><span class="identifier">signIn</span><span class="none">
    .</span><span class="identifier">sink</span><span class="none"> { </span><span class="identifier">result</span><span class="none"> </span><span class="keyword">in</span><span class="none">
        </span><span class="identifier">somethingUnexpected</span><span class="none">(</span><span class="identifier">with</span><span class="none">: </span><span class="identifier">result</span><span class="none">)
    }
    .</span><span class="identifier">store</span><span class="none">(</span><span class="identifier">in</span><span class="none">: &amp;</span><span class="identifier">cancellables</span><span class="none">)
</span></code></pre><p>Consider the situation where you happen to be tracking down a bug that occurs when your users attempt to authenticate.Because we have exposed a <code>Subject</code> we have to check all the subscriptions to the <code>signInResult</code> output <em>but also</em> any subscriptions to the <code>signIn</code> input!This makes things harder than they should beâ€¦</p><p>Let's take a look at a simple approach to get our encapsulation back:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signIn</span><span class="none"> = </span><span class="identifier">PassthroughSubject</span><span class="none">&lt;(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">), </span><span class="type">Never</span><span class="none">&gt;()

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="identifier">signInResult</span><span class="none"> = </span><span class="identifier">signIn</span><span class="none">
            .</span><span class="identifier">flatMap</span><span class="none"> { </span><span class="identifier">input</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">API</span><span class="none">
                    .</span><span class="identifier">authenticate</span><span class="none">(</span><span class="identifier">input</span><span class="none">.</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">input</span><span class="none">.</span><span class="identifier">password</span><span class="none">)
                    .</span><span class="identifier">materialize</span><span class="none">()
            }
            .</span><span class="identifier">eraseToAnyPublisher</span><span class="none">()
    }

    </span><span class="comment">// MARK: - Public Functions</span><span class="none">
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">signIn</span><span class="none">(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">) {
        </span><span class="identifier">signIn</span><span class="none">.</span><span class="identifier">send</span><span class="none">((</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">password</span><span class="none">))
    }
}
</span></code></pre><p>Much better! We now have closed off the ability for unintended side effects by giving <code>signIn</code> a <code>private</code> access level.Consumers of the view model can now use the <code>signIn(username:password:)</code> function to perform an authentication attempt.</p><p>Now we could stop here and it would be perfectly fine, but having to maintain a <code>Subject</code> <em>and</em> a function bothers me justenough to potentially over-engineer an alternativeâ€¦ strap yourself in.</p><h2>Inputs!â€¦ for real this time</h2><p>What we want is a type that exposes a way to <em>send</em> values publicly, but <em>derive</em> streams using them internally.My first thought was to try using PropertyWrappers since we can take advantage of the <code>_value</code> syntax to gain the encapsulation we want:</p><pre><code class="language-swift"><span class="keyword">@propertyWrapper</span><span class="none">
</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Input</span><span class="none">&lt;</span><span class="identifier">Parameters</span><span class="none">&gt; {
    </span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">SendProxy</span><span class="none"> {
        </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">send</span><span class="none">: (</span><span class="type">Parameters</span><span class="none">) -&gt; </span><span class="type">Void</span><span class="none">
    }

    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">wrappedValue</span><span class="none">: </span><span class="type">Parameters</span><span class="none"> { </span><span class="identifier">fatalError</span><span class="none">(</span><span class="literal">&quot;Send values via the $projectedValue&quot;</span><span class="none">) }
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">projectedValue</span><span class="none">: </span><span class="type">SendProxy</span><span class="none"> { .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">send</span><span class="none">: </span><span class="identifier">subject</span><span class="none">.</span><span class="identifier">send</span><span class="none">) }

    </span><span class="keyword">init</span><span class="none">() { }

    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">subject</span><span class="none"> = </span><span class="identifier">PassthroughSubject</span><span class="none">&lt;</span><span class="type">Parameters</span><span class="none">, </span><span class="type">Never</span><span class="none">&gt;()
}
</span></code></pre><p>There's a fair bit going on in this little snippet so let's unpack it quicklyâ€¦</p><p>The reason I first thought PropertyWrappers might be a good solution is because they allow us to expose things differently.We can use the publicly visible members (<code>wrappedValue</code> and <code>projectedValue</code>) to expose the parameters for the input and a way to send them.We can them use the restricted members (the <code>_underscore</code> accessor) to give the enclosing type exclusive access to the <code>Subject</code>.</p><p>We don't really want the <code>wrappedValue</code> here, it's just a means to expose a generic parameter.The <code>projectedValue</code> exposes a <code>SendProxy</code> which is just a way for use to provide <em>only</em> the <code>send</code> function to code outside the view model.</p><p>Clear as mud? Let's take a look at how we might use this in our view model and hopefully it'll make sense:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">@</span><span class="type">Input</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signIn</span><span class="none">: (</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">)

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="identifier">signInResult</span><span class="none"> = </span><span class="identifier">_signIn</span><span class="none"> </span><span class="comment">// underscore accessor let&apos;s us use the `Subject` exclusively</span><span class="none">
            .</span><span class="identifier">subject</span><span class="none">
            .</span><span class="identifier">flatMap</span><span class="none"> { </span><span class="identifier">input</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">API</span><span class="none">
                    .</span><span class="identifier">authenticate</span><span class="none">(</span><span class="identifier">input</span><span class="none">.</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">input</span><span class="none">.</span><span class="identifier">password</span><span class="none">)
                    .</span><span class="identifier">materialize</span><span class="none">()
            }
            .</span><span class="identifier">eraseToAnyPublisher</span><span class="none">()
    }
}
</span></code></pre><p>We can now sue the following syntax to send values:</p><pre><code class="language-swift"><span class="identifier">viewModel</span><span class="none">.</span><span class="identifier">$signIn</span><span class="none">.</span><span class="identifier">send</span><span class="none">((</span><span class="identifier">username</span><span class="none">: </span><span class="literal">&quot;...&quot;</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="literal">&quot;...&quot;</span><span class="none">))
</span></code></pre><p>The PropertyWrapper itself is a little crazy, but the view model and the call site is a little cleaner I think.Unfortunately there is actually a pretty big downside to this approach, PropertyWrappers can't be enforced in protocols.</p><p>Consider this:</p><pre><code class="language-swift"><span class="keyword">protocol</span><span class="none"> </span><span class="identifier">AuthViewModelType</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt; { </span><span class="keyword">get</span><span class="none"> }

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">@</span><span class="type">Input</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signIn</span><span class="none">: (</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">) { </span><span class="keyword">get</span><span class="none"> } </span><span class="comment">// Property &apos;signIn&apos; declared inside a protocol cannot have a wrapper</span><span class="none">
}
</span></code></pre><p>Since we can't enforce <code>@Input</code> it means code that only knows about the <code>AuthViewModelType</code> wouldn't have visibility to call the <code>$signIn.send</code>  function.</p><p>This is a bit of a show stopper. I don't usually use protocols for view models but for other Combine friendly dependencies I might create I want to be able to enforce strict input/outputs.</p><p>Take two, let's try using a concrete type:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">AnyConsumer</span><span class="none">&lt;</span><span class="identifier">Output</span><span class="none">&gt; {
    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">subject</span><span class="none"> = </span><span class="identifier">PassthroughSubject</span><span class="none">&lt;</span><span class="type">Output</span><span class="none">, </span><span class="type">Never</span><span class="none">&gt;()

    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">send</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="type">Output</span><span class="none">) {
        </span><span class="identifier">subject</span><span class="none">.</span><span class="identifier">send</span><span class="none">(</span><span class="identifier">value</span><span class="none">)
    }
}
</span></code></pre><p>I'm calling this <code>AnyConsumer</code> because it feels like a nice parallel with <code>AnyPublisher</code>.  This type allows us to expose <em>just</em> the <code>send</code> function making this type <em>input only</em> just like we want;however, if we make the subject <code>private</code> nothing is going to be able to access it. It feels like we are stuck in a catch 22.</p><p>Let's go with it for now and update the rest of our code; first let's make our protocol enforce our strict input:</p><pre><code class="language-swift"><span class="keyword">protocol</span><span class="none"> </span><span class="identifier">AuthViewModelType</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt; { </span><span class="keyword">get</span><span class="none"> }

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signIn</span><span class="none">: </span><span class="type">AnyConsumer</span><span class="none">&lt;(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">)&gt; { </span><span class="keyword">get</span><span class="none"> }
}
</span></code></pre><p>The next step is to update our view model to conform to these changes:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none">: </span><span class="type">AuthViewModelType</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signIn</span><span class="none"> = </span><span class="identifier">AnyConsumer</span><span class="none">&lt;(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">)&gt;()

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="identifier">signInResult</span><span class="none"> = </span><span class="identifier">signIn</span><span class="none">
            .</span><span class="identifier">subject</span><span class="none"> </span><span class="comment">// &apos;subject&apos; is inaccessible due to &apos;private&apos; protection level</span><span class="none">
            .</span><span class="identifier">flatMap</span><span class="none"> { </span><span class="identifier">input</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">API</span><span class="none">
                    .</span><span class="identifier">authenticate</span><span class="none">(</span><span class="identifier">input</span><span class="none">.</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">input</span><span class="none">.</span><span class="identifier">password</span><span class="none">)
                    .</span><span class="identifier">materialize</span><span class="none">()
            }
            .</span><span class="identifier">eraseToAnyPublisher</span><span class="none">()
    }
}
</span></code></pre><p>Just as we expected, while we gained the encapsulation benefits of a strict input type the view model isn't able to access the underlying <code>Subject</code> to use the values coming in.</p><p>We need a way to expose thee <code>Subject</code> but <em>only</em> to our view model. As it turns out we can actually use PropertyWrappers again to accomplish that!</p><p>We can bring back our <code>@Input</code> PropertyWrapper in a new form. This time it will work <em>with</em> <code>AnyConsumer</code> to expose the <code>Subject</code> to the enclosing type but will be hidden from everything else.</p><p>Lets update <code>AnyConsumer</code> and see what that looks like:</p><pre><code class="language-swift"><span class="keyword">@propertyWrapper</span><span class="none">
</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Input</span><span class="none">&lt;</span><span class="identifier">Output</span><span class="none">&gt; {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">wrappedValue</span><span class="none">: </span><span class="type">AnyConsumer</span><span class="none">&lt;</span><span class="type">Output</span><span class="none">&gt;

    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">subject</span><span class="none">: </span><span class="type">PassthroughSubject</span><span class="none">&lt;</span><span class="type">Output</span><span class="none">, </span><span class="type">Never</span><span class="none">&gt; { </span><span class="identifier">wrappedValue</span><span class="none">.</span><span class="identifier">subject</span><span class="none"> }
}

</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">AnyConsumer</span><span class="none">&lt;</span><span class="identifier">Output</span><span class="none">&gt; {
    </span><span class="keyword">fileprivate</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">subject</span><span class="none"> = </span><span class="identifier">PassthroughSubject</span><span class="none">&lt;</span><span class="type">Output</span><span class="none">, </span><span class="type">Never</span><span class="none">&gt;()

    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">send</span><span class="none">(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="type">Output</span><span class="none">) {
        </span><span class="identifier">subject</span><span class="none">.</span><span class="identifier">send</span><span class="none">(</span><span class="identifier">value</span><span class="none">)
    }
}
</span></code></pre><p>Now we can Combine (pun intended) our <code>@Input</code> PropertyWrapper with our <code>AnyConsumer</code> to restrict access to each side of the underlying <code>Subject</code>.</p><p>We have exclusive access for the view model to read the input:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">AuthViewModel</span><span class="none">: </span><span class="type">AuthViewModelType</span><span class="none"> {
    </span><span class="comment">// MARK: - Outputs</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">signInResult</span><span class="none">: </span><span class="type">AnyPublisher</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">&lt;</span><span class="type">Token</span><span class="none">, </span><span class="type">Error</span><span class="none">&gt;, </span><span class="type">Never</span><span class="none">&gt;

    </span><span class="comment">// MARK: - Inputs</span><span class="none">
    </span><span class="keyword">@</span><span class="type">Input</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">signIn</span><span class="none"> = </span><span class="identifier">AnyConsumer</span><span class="none">&lt;(</span><span class="identifier">username</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="type">String</span><span class="none">)&gt;()

    </span><span class="comment">// MARK: - Lifecycle</span><span class="none">
    </span><span class="keyword">init</span><span class="none">() {
        </span><span class="identifier">signInResult</span><span class="none"> = </span><span class="identifier">_signIn</span><span class="none">
            .</span><span class="identifier">subject</span><span class="none">
            .</span><span class="identifier">flatMap</span><span class="none"> { </span><span class="identifier">input</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">API</span><span class="none">
                    .</span><span class="identifier">authenticate</span><span class="none">(</span><span class="identifier">input</span><span class="none">.</span><span class="identifier">username</span><span class="none">, </span><span class="identifier">input</span><span class="none">.</span><span class="identifier">password</span><span class="none">)
                    .</span><span class="identifier">materialize</span><span class="none">()
            }
            .</span><span class="identifier">eraseToAnyPublisher</span><span class="none">()
    }
}
</span></code></pre><p>And, as before, anything using the view model can <em>only</em> see and call <code>.send</code>:</p><pre><code class="language-swift"><span class="identifier">viewModel</span><span class="none">.</span><span class="identifier">signIn</span><span class="none">.</span><span class="identifier">send</span><span class="none">((</span><span class="identifier">username</span><span class="none">: </span><span class="literal">&quot;...&quot;</span><span class="none">, </span><span class="identifier">password</span><span class="none">: </span><span class="literal">&quot;...&quot;</span><span class="none">))
</span></code></pre><h2>Wrap up</h2><p>So after all that we have ended up with something that allows us to nicely encapsulate access to two sides of a <code>Subject</code>.Is the extra abstraction worth it over our original private subject/function solution? There are a couple of nice advantages our final solution has that I can think of</p><p>Less typing: that's always a nice win. Using <code>AnyConsumer</code> we  don't have to maintain a private subject as well as an additional function to get into the <code>send</code> function.</p><p>An explicit type: having this not only draws a nice parallel with other output types like <code>AnyPublisher</code> but it gives us an anchor point for things like UI bindings.Think about how you might write a button binding today:</p><pre><code class="language-swift"><span class="identifier">someButton</span><span class="none">.</span><span class="identifier">combine</span><span class="none">.</span><span class="identifier">tap</span><span class="none"> </span><span class="comment">// example tap publisher</span><span class="none">
    .</span><span class="identifier">sink</span><span class="none"> { [</span><span class="identifier">unowned</span><span class="none"> </span><span class="keyword">self</span><span class="none">] </span><span class="keyword">in</span><span class="none">
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">viewModel</span><span class="none">.</span><span class="identifier">signIn</span><span class="none">()
    }
</span></code></pre><p>Using  <code>AnyConsumer</code> we could rewrite this subtly:</p><pre><code class="language-swift"><span class="identifier">someButton</span><span class="none">.</span><span class="identifier">combine</span><span class="none">.</span><span class="identifier">tap</span><span class="none">
    .</span><span class="identifier">bind</span><span class="none">(</span><span class="identifier">to</span><span class="none">: </span><span class="identifier">viewModel</span><span class="none">.</span><span class="identifier">signIn</span><span class="none">)
    .</span><span class="identifier">store</span><span class="none">(</span><span class="identifier">in</span><span class="none">: &amp;</span><span class="identifier">cancellables</span><span class="none">)
</span></code></pre><p>The change is minor but again it's slightly more concise and we can remove the burden of things like managing memory semantics and capture lists from our users.</p><p>That's all I have for now, but I'd love to hear any thoughts on this :)</p></div><div id="page-footer"><div class="divider"></div><p>(c) Ian Keen</p></div></body></html>