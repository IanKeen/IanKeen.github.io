<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content=""><meta name="author" content="Ian Keen"><meta og:site_name="Type safe temporary models"><meta og:title="Type safe temporary models"><meta og:description=""><meta og:url="https://iankeen.tech"><meta twitter:card="summary"><meta twitter:site="@IanKay"><meta twitter:creator="@IanKay"><meta twitter:title="Type safe temporary models"><meta twitter:description=""><title>devbits: random development bits by Ian Keen</title><link rel="stylesheet" href="/Resources/style.css"><link rel="stylesheet" href="/Resources/swift.css"><link rel="shortcut icon" href="/Resources/favicon.ico"></head><body><div id="page-header"><a href="/"><div id="logo" class="wiggle"><p>devbits</p></div></a><div id="links"><div id="me"><a href="/workwithme/index.html">work with me</a><a href="/about/index.html">about</a></div><div id="social"><a href="https://www.twitter.com/IanKay"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tLjEzOSA5LjIzN2MuMjA5IDQuNjE3LTMuMjM0IDkuNzY1LTkuMzMgOS43NjUtMS44NTQgMC0zLjU3OS0uNTQzLTUuMDMyLTEuNDc1IDEuNzQyLjIwNSAzLjQ4LS4yNzggNC44Ni0xLjM1OS0xLjQzNy0uMDI3LTIuNjQ5LS45NzYtMy4wNjYtMi4yOC41MTUuMDk4IDEuMDIxLjA2OSAxLjQ4Mi0uMDU2LTEuNTc5LS4zMTctMi42NjgtMS43MzktMi42MzMtMy4yNi40NDIuMjQ2Ljk0OS4zOTQgMS40ODYuNDExLTEuNDYxLS45NzctMS44NzUtMi45MDctMS4wMTYtNC4zODMgMS42MTkgMS45ODYgNC4wMzggMy4yOTMgNi43NjYgMy40My0uNDc5LTIuMDUzIDEuMDgtNC4wMyAzLjE5OS00LjAzLjk0MyAwIDEuNzk3LjM5OCAyLjM5NSAxLjAzNy43NDgtLjE0NyAxLjQ1MS0uNDIgMi4wODYtLjc5Ni0uMjQ2Ljc2Ny0uNzY2IDEuNDEtMS40NDMgMS44MTYuNjY0LS4wOCAxLjI5Ny0uMjU2IDEuODg1LS41MTctLjQzOS42NTYtLjk5NiAxLjIzNC0xLjYzOSAxLjY5N3oiLz48L3N2Zz4="></a><a href="https://www.github.com/IanKeen"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tNC40NjYgMTkuNTljLS40MDUuMDc4LS41MzQtLjE3MS0uNTM0LS4zODR2LTIuMTk1YzAtLjc0Ny0uMjYyLTEuMjMzLS41NS0xLjQ4MSAxLjc4Mi0uMTk4IDMuNjU0LS44NzUgMy42NTQtMy45NDcgMC0uODc0LS4zMTItMS41ODgtLjgyMy0yLjE0Ny4wODItLjIwMi4zNTYtMS4wMTYtLjA3OS0yLjExNyAwIDAtLjY3MS0uMjE1LTIuMTk4LjgyLS42NC0uMTgtMS4zMjQtLjI2Ny0yLjAwNC0uMjcxLS42OC4wMDMtMS4zNjQuMDkxLTIuMDAzLjI2OS0xLjUyOC0xLjAzNS0yLjItLjgyLTIuMi0uODItLjQzNCAxLjEwMi0uMTYgMS45MTUtLjA3NyAyLjExOC0uNTEyLjU2LS44MjQgMS4yNzMtLjgyNCAyLjE0NyAwIDMuMDY0IDEuODY3IDMuNzUxIDMuNjQ1IDMuOTU0LS4yMjkuMi0uNDM2LjU1Mi0uNTA4IDEuMDctLjQ1Ny4yMDQtMS42MTQuNTU3LTIuMzI4LS42NjYgMCAwLS40MjMtLjc2OC0xLjIyNy0uODI1IDAgMC0uNzgtLjAxLS4wNTUuNDg3IDAgMCAuNTI1LjI0Ni44ODkgMS4xNyAwIDAgLjQ2MyAxLjQyOCAyLjY4OC45NDR2MS40ODljMCAuMjExLS4xMjkuNDU5LS41MjguMzg1LTMuMTgtMS4wNTctNS40NzItNC4wNTYtNS40NzItNy41OSAwLTQuNDE5IDMuNTgyLTggOC04czggMy41ODEgOCA4YzAgMy41MzMtMi4yODkgNi41MzEtNS40NjYgNy41OXoiLz48L3N2Zz4="></a><a href="https://iankeen.tech/feed.rss"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tMTIuODMyIDIwYy0xLjE5NyAwLTIuMTY4LS45NjktMi4xNjgtMi4xNjVzLjk3MS0yLjE2NSAyLjE2OC0yLjE2NSAyLjE2Ny45NjkgMi4xNjcgMi4xNjUtLjk3IDIuMTY1LTIuMTY3IDIuMTY1em01LjE4IDBjLS4wNDEtNC4wMjktMy4zMTQtNy4yOTgtNy4zNDgtNy4zMzl2LTMuMjA3YzUuODE0LjA0MSAxMC41MTggNC43MzkgMTAuNTYxIDEwLjU0NmgtMy4yMTN6bTUuNDQxIDBjLS4wMjEtNy4wNjMtNS43MzYtMTIuNzYxLTEyLjc4OS0xMi43OTJ2LTMuMjA4YzguODMuMDMxIDE1Ljk4IDcuMTc5IDE2IDE2aC0zLjIxMXoiLz48L3N2Zz4="></a></div></div></div><div id="page-title"><h1 class="title plain">Type safe temporary models</h1><h2 class="when">05 Jun 2018</h2><div id="tags"><div class="tag-container"><div class="tag"><a href="/tags/generics/index.html">Generics</a></div></div></div><div class="divider"></div></div><div id="page-content"><p>Recently I had to build a system to onboard users. This meant collecting different pieces of information over a number of screens. We are also utilizing A/B testing which means not only can the order of screens change, but certain pieces of information may be collected by a single screen or broken up across many.</p><p>The data I want to end up with looks something like:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">User</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">firstName</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">lastName</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">age</span><span class="none">: </span><span class="type">Int</span><span class="none">?
}
</span></code></pre><p>There are multiple ways to go about collecting this data, I could simply give each screen an optional property:</p><pre><code class="language-swift"><span class="keyword">class</span><span class="none"> </span><span class="identifier">FirstNameViewController</span><span class="none">: </span><span class="type">UIViewController</span><span class="none"> {
    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">firstName</span><span class="none">: </span><span class="type">String</span><span class="none">?

    </span><span class="comment">// ...</span><span class="none">
}
</span></code></pre><p>This would get the job done, but there are a few problems to overcome...</p><ul><li>What about the A/B testing? We would very quickly end up with our screens having a number of the same optional properties.</li><li>How do we keep track of and consolidate all of these properties at the end?</li></ul><p>An alternate approach would be to have a second version of our model with optional properties, such as:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">PartialUser</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">firstName</span><span class="none">: </span><span class="type">String</span><span class="none">?
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">lastName</span><span class="none">: </span><span class="type">String</span><span class="none">?
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">age</span><span class="none">: </span><span class="type">Int</span><span class="none">?
}
</span></code></pre><p>This is an improvement, we now have all the pieces in one place. We can create a <code>User.init</code> that accepts this model to produce a complete <code>User</code> instance for us:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">User</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">partial</span><span class="none">: </span><span class="type">PartialUser</span><span class="none">) {
        </span><span class="comment">// ...</span><span class="none">
    }
}
</span></code></pre><p>However it comes with it own set of problems...</p><ul><li>We have to keep it in sync with the 'real' model</li><li>This <code>init</code> can look a little messy having to deal with both required and optional properties</li><li>What do we do when a required value is missing?</li></ul><p>It's worth noting that neither of these solution scale well for other uses, there is a lot of associated boilerplate that we would need to replicate for each specific use case.</p><p>We could try to solve the scaling problem with a <code>Dictionary</code>... what about using <code>[String: Any]</code>? While this scales fine it's a step backwards in safety.</p><p><code>String</code> keys are problematic, they are prone to typos and will easily fall out of sync. We could look at using a <code>String</code> enum but then we've re-introduced our scaling issue again!</p><p>On the value side <code>Any</code> strips all our type information and we would then have to cast values back top the desired types again anyway.</p><p>What we need is something that combines the last two attempts. It should scale like a dictionary but gives us the type safety of an explicit model.</p><p>Lets stick with the <code>Dictionary</code> for now. Can we improve on <code>String</code> keys? Turns out Swift <code>KeyPath</code>s are a great solution to this!</p><pre><code class="language-swift"><span class="keyword">var</span><span class="none"> </span><span class="identifier">partialUser</span><span class="none">: [</span><span class="type">PartialKeyPath</span><span class="none">&lt;</span><span class="type">User</span><span class="none">&gt;: </span><span class="keyword">Any</span><span class="none">] = [:]
</span></code></pre><p>By using a <code>PartialKeyPath</code> we are able to restrict the keys to <em>only</em> properties on <code>User</code> like so:</p><pre><code class="language-swift"><span class="identifier">partialUser</span><span class="none">[\</span><span class="identifier">User</span><span class="none">.</span><span class="identifier">firstName</span><span class="none">] = </span><span class="literal">&quot;Ian&quot;</span><span class="none">
</span></code></pre><p>This is great! Now if our <code>User</code> model changes this dictionary will scale perfectly with it. New properties will be available as they are added and changes to existing properties will cause the compiler to complain.</p><p>What about the pesky <code>Any</code>? Right now you could replace the <code>String</code> value <code>"Ian"</code> with something like an <code>Int</code> of <code>42</code> and it would still compile (though it will fail when you try and extract it). Is there a different type we can use here to fix that?</p><p>Sadly no...</p><p>But there is hope! Let's build a new type that will solve this problem <em>and</em> make this solution more <em>generic</em> (pun intended üòÑ)</p><h2>Partial<T></h2><p>Let's start by putting in the <code>KeyPath</code> based <code>Dictionary</code> we have already to keep track of our changes:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Partial</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt; {
    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">data</span><span class="none">: [</span><span class="type">PartialKeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">&gt;: </span><span class="keyword">Any</span><span class="none">] = [:]

    </span><span class="comment">//...</span><span class="none">
}
</span></code></pre><p>This gives us a generic type that we can now use with <em>any</em> type we want:</p><pre><code class="language-swift"><span class="keyword">var</span><span class="none"> </span><span class="identifier">partial</span><span class="none"> = </span><span class="identifier">Partial</span><span class="none">&lt;</span><span class="type">User</span><span class="none">&gt;()
</span></code></pre><p>Next, we can use a generic function to ensure the dictionary is updated with the correct types:</p><pre><code class="language-swift"><span class="keyword">mutating</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">update</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;, </span><span class="identifier">to</span><span class="none"> </span><span class="identifier">newValue</span><span class="none">: </span><span class="type">U</span><span class="none">?) {
    </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] = </span><span class="identifier">newValue</span><span class="none">
}
</span></code></pre><p>We use a <em>full</em> <code>KeyPath</code> here so we can gain access to the generic type of the value of the property. This works because <code>KeyPath</code> is a subclass of <code>PartialKeyPath</code>. With this function we can now update the data using:</p><pre><code class="language-swift"><span class="identifier">partial</span><span class="none">.</span><span class="identifier">update</span><span class="none">(\.</span><span class="identifier">firstName</span><span class="none">, </span><span class="identifier">to</span><span class="none">: </span><span class="literal">&quot;Ian&quot;</span><span class="none">)
</span></code></pre><p>And because we now have access to the properties type we can restrict the value being set. For instance we can no longer pass <code>42</code>. It's also worth noting that we can pass <code>nil</code> to erase any stored value too! We now have a type safe, scalable, setter!</p><p>We can use these same features to also build out the getter:</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">U</span><span class="none"> {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none"> = </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] </span><span class="keyword">as</span><span class="none">? </span><span class="type">U</span><span class="none"> </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">throw</span><span class="none"> </span><span class="identifier">Error</span><span class="none">.</span><span class="identifier">valueNotFound</span><span class="none"> }
    </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">value</span><span class="none">
}
</span></code></pre><p>Here we are encapsulating the casting of <code>Any</code> to the desired type and adding error handling. We also add in an overload to allow us to deal with optionals in a consistent way.</p><h2>Dragons! üêâ</h2><p>I should point out that there is one potential gotcha with the current implementation... when you use <code>update(_:to:)</code> you are only associating a single <code>KeyPath</code> with a single value. What this means is that if you are working with data like:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Pet</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
}
</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">User</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">pet</span><span class="none">: </span><span class="type">Pet</span><span class="none">
}
</span></code></pre><p>And you update the value like so:</p><pre><code class="language-swift"><span class="keyword">var</span><span class="none"> </span><span class="identifier">partial</span><span class="none"> = </span><span class="identifier">Partial</span><span class="none">&lt;</span><span class="type">User</span><span class="none">&gt;()
</span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">update</span><span class="none">(\.</span><span class="identifier">pet</span><span class="none">, </span><span class="identifier">to</span><span class="none">: </span><span class="identifier">Pet</span><span class="none">(</span><span class="identifier">name</span><span class="none">: </span><span class="literal">&quot;Rover&quot;</span><span class="none">))
</span></code></pre><p>This only creates a pairing of the <code>pet</code> <code>KeyPath</code> and the <code>Pet</code> object, you cannot then extract the nested data using:</p><pre><code class="language-swift"><span class="keyword">let</span><span class="none"> </span><span class="identifier">petName</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">pet</span><span class="none">.</span><span class="identifier">name</span><span class="none">)
</span></code></pre><p>This will fail because the inner <code>Dictionary</code> does not have an entry for <code>\.pet.name</code>... only <code>\.pet</code>. You need to ensure you are first extracting the data using a <code>KeyPath</code> you have already used <em>then</em> accessing the data from that:</p><pre><code class="language-swift"><span class="keyword">let</span><span class="none"> </span><span class="identifier">pet</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">pet</span><span class="none">)
</span><span class="keyword">let</span><span class="none"> </span><span class="identifier">petName</span><span class="none"> = </span><span class="identifier">pet</span><span class="none">.</span><span class="identifier">name</span><span class="none">
</span></code></pre><p>To correct this we can add an overload for <code>value(for:)</code> that first extracts the stored property then allows us you use <code>KeyPath</code>s to dig further down:</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">, </span><span class="identifier">V</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;, </span><span class="keyword">_</span><span class="none"> </span><span class="identifier">inner</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">U</span><span class="none">, </span><span class="type">V</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">V</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">root</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: </span><span class="identifier">keyPath</span><span class="none">)
    </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">root</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">: </span><span class="identifier">inner</span><span class="none">]
}
</span></code></pre><p>Using this you could then do</p><pre><code class="language-swift"><span class="keyword">let</span><span class="none"> </span><span class="identifier">petName</span><span class="none">: </span><span class="type">String</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">pet</span><span class="none">, \.</span><span class="identifier">name</span><span class="none">)
</span></code></pre><p>This is great because once you have the 'root' object the inner <code>KeyPath</code> can dig down any number of nested levels.</p><h2>Putting it all together</h2><p>This is what our full <code>Partial<T></code> looks like. I've also added some overloads to better handle optionals too:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Partial</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt; {
    </span><span class="keyword">enum</span><span class="none"> </span><span class="identifier">Error</span><span class="none">: </span><span class="type">Swift</span><span class="none">.</span><span class="type">Error</span><span class="none"> {
        </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">valueNotFound</span><span class="none">
    }

    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">data</span><span class="none">: [</span><span class="type">PartialKeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">&gt;: </span><span class="keyword">Any</span><span class="none">] = [:]

    </span><span class="keyword">mutating</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">update</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;, </span><span class="identifier">to</span><span class="none"> </span><span class="identifier">newValue</span><span class="none">: </span><span class="type">U</span><span class="none">?) {
        </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] = </span><span class="identifier">newValue</span><span class="none">
    }
    </span><span class="keyword">mutating</span><span class="none"> </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">update</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">?&gt;, </span><span class="identifier">to</span><span class="none"> </span><span class="identifier">newValue</span><span class="none">: </span><span class="type">U</span><span class="none">?) {
        </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] = </span><span class="identifier">newValue</span><span class="none">
    }
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">U</span><span class="none"> {
        </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none"> = </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] </span><span class="keyword">as</span><span class="none">? </span><span class="type">U</span><span class="none"> </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">throw</span><span class="none"> </span><span class="identifier">Error</span><span class="none">.</span><span class="identifier">valueNotFound</span><span class="none"> }
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">value</span><span class="none">
    }
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">?&gt;) -&gt; </span><span class="type">U</span><span class="none">? {
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">data</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">] </span><span class="keyword">as</span><span class="none">? </span><span class="type">U</span><span class="none">
    }
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">, </span><span class="identifier">V</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">&gt;, </span><span class="keyword">_</span><span class="none"> </span><span class="identifier">inner</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">U</span><span class="none">, </span><span class="type">V</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">V</span><span class="none"> {
        </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">root</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: </span><span class="identifier">keyPath</span><span class="none">)
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">root</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">: </span><span class="identifier">inner</span><span class="none">]
    }
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">U</span><span class="none">, </span><span class="identifier">V</span><span class="none">&gt;(</span><span class="identifier">for</span><span class="none"> </span><span class="identifier">keyPath</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">T</span><span class="none">, </span><span class="type">U</span><span class="none">?&gt;, </span><span class="keyword">_</span><span class="none"> </span><span class="identifier">inner</span><span class="none">: </span><span class="type">KeyPath</span><span class="none">&lt;</span><span class="type">U</span><span class="none">, </span><span class="type">V</span><span class="none">&gt;) -&gt; </span><span class="type">V</span><span class="none">? {
        </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">root</span><span class="none"> = </span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: </span><span class="identifier">keyPath</span><span class="none">) </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">return</span><span class="none"> </span><span class="keyword">nil</span><span class="none"> }
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">root</span><span class="none">[</span><span class="identifier">keyPath</span><span class="none">: </span><span class="identifier">inner</span><span class="none">]
    }
}
</span></code></pre><p>And we can now extend our original <code>User</code> model like so:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">User</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">partial</span><span class="none">: </span><span class="type">Partial</span><span class="none">&lt;</span><span class="type">User</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">firstName</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">firstName</span><span class="none">)
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">lastName</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">lastName</span><span class="none">)
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">age</span><span class="none"> = </span><span class="identifier">partial</span><span class="none">.</span><span class="identifier">value</span><span class="none">(</span><span class="identifier">for</span><span class="none">: \.</span><span class="identifier">age</span><span class="none">)
    }
}
</span></code></pre><h2>Wrapping up</h2><p>Sadly we are not able to provide a default implementation for the convenience <code>init</code> <em>yet</em>. I've explored a few ways of getting this to work however the core issue is that there is, currently, no way of converting to or from <code>KeyPath</code>s to other types.</p><p>It's a shame but regardless, I think this is an interesting use of <code>KeyPath</code>s. I also like the feel of this solution when compared to the other attempts because of the ability to exactly mirror the underlying model and the resulting compiler safety.</p><p><strong>UPDATE:</strong> I forgot to mention that while there is no way to provide a default implementation for the convenience <code>init</code> you <em>can</em> of course use a tool like <a href="https://github.com/krzysztofzablocki/Sourcery">Sourcery</a> to do this for you until <code>KeyPath</code>s get some love.</p><p>Let me know what you think!</p></div><div id="page-footer"><div class="divider"></div><p>(c) Ian Keen</p></div></body></html>