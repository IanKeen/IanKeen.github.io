<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content=""><meta name="author" content="Ian Keen"><meta og:site_name="Improving Codable for enums with associated values"><meta og:title="Improving Codable for enums with associated values"><meta og:description=""><meta og:url="https://iankeen.tech"><meta twitter:card="summary"><meta twitter:site="@IanKay"><meta twitter:creator="@IanKay"><meta twitter:title="Improving Codable for enums with associated values"><meta twitter:description=""><title>devbits: random development bits by Ian Keen</title><link rel="stylesheet" href="/Resources/style.css"><link rel="stylesheet" href="/Resources/swift.css"><link rel="shortcut icon" href="/Resources/favicon.ico"></head><body><div id="page-header"><a href="/"><div id="logo" class="wiggle"><p>devbits</p></div></a><div id="links"><div id="me"><a href="/workwithme/index.html">work with me</a><a href="/about/index.html">about</a></div><div id="social"><a href="https://www.twitter.com/IanKay"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tLjEzOSA5LjIzN2MuMjA5IDQuNjE3LTMuMjM0IDkuNzY1LTkuMzMgOS43NjUtMS44NTQgMC0zLjU3OS0uNTQzLTUuMDMyLTEuNDc1IDEuNzQyLjIwNSAzLjQ4LS4yNzggNC44Ni0xLjM1OS0xLjQzNy0uMDI3LTIuNjQ5LS45NzYtMy4wNjYtMi4yOC41MTUuMDk4IDEuMDIxLjA2OSAxLjQ4Mi0uMDU2LTEuNTc5LS4zMTctMi42NjgtMS43MzktMi42MzMtMy4yNi40NDIuMjQ2Ljk0OS4zOTQgMS40ODYuNDExLTEuNDYxLS45NzctMS44NzUtMi45MDctMS4wMTYtNC4zODMgMS42MTkgMS45ODYgNC4wMzggMy4yOTMgNi43NjYgMy40My0uNDc5LTIuMDUzIDEuMDgtNC4wMyAzLjE5OS00LjAzLjk0MyAwIDEuNzk3LjM5OCAyLjM5NSAxLjAzNy43NDgtLjE0NyAxLjQ1MS0uNDIgMi4wODYtLjc5Ni0uMjQ2Ljc2Ny0uNzY2IDEuNDEtMS40NDMgMS44MTYuNjY0LS4wOCAxLjI5Ny0uMjU2IDEuODg1LS41MTctLjQzOS42NTYtLjk5NiAxLjIzNC0xLjYzOSAxLjY5N3oiLz48L3N2Zz4="></a><a href="https://www.github.com/IanKeen"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tNC40NjYgMTkuNTljLS40MDUuMDc4LS41MzQtLjE3MS0uNTM0LS4zODR2LTIuMTk1YzAtLjc0Ny0uMjYyLTEuMjMzLS41NS0xLjQ4MSAxLjc4Mi0uMTk4IDMuNjU0LS44NzUgMy42NTQtMy45NDcgMC0uODc0LS4zMTItMS41ODgtLjgyMy0yLjE0Ny4wODItLjIwMi4zNTYtMS4wMTYtLjA3OS0yLjExNyAwIDAtLjY3MS0uMjE1LTIuMTk4LjgyLS42NC0uMTgtMS4zMjQtLjI2Ny0yLjAwNC0uMjcxLS42OC4wMDMtMS4zNjQuMDkxLTIuMDAzLjI2OS0xLjUyOC0xLjAzNS0yLjItLjgyLTIuMi0uODItLjQzNCAxLjEwMi0uMTYgMS45MTUtLjA3NyAyLjExOC0uNTEyLjU2LS44MjQgMS4yNzMtLjgyNCAyLjE0NyAwIDMuMDY0IDEuODY3IDMuNzUxIDMuNjQ1IDMuOTU0LS4yMjkuMi0uNDM2LjU1Mi0uNTA4IDEuMDctLjQ1Ny4yMDQtMS42MTQuNTU3LTIuMzI4LS42NjYgMCAwLS40MjMtLjc2OC0xLjIyNy0uODI1IDAgMC0uNzgtLjAxLS4wNTUuNDg3IDAgMCAuNTI1LjI0Ni44ODkgMS4xNyAwIDAgLjQ2MyAxLjQyOCAyLjY4OC45NDR2MS40ODljMCAuMjExLS4xMjkuNDU5LS41MjguMzg1LTMuMTgtMS4wNTctNS40NzItNC4wNTYtNS40NzItNy41OSAwLTQuNDE5IDMuNTgyLTggOC04czggMy41ODEgOCA4YzAgMy41MzMtMi4yODkgNi41MzEtNS40NjYgNy41OXoiLz48L3N2Zz4="></a><a href="https://iankeen.tech/feed.rss"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tMTIuODMyIDIwYy0xLjE5NyAwLTIuMTY4LS45NjktMi4xNjgtMi4xNjVzLjk3MS0yLjE2NSAyLjE2OC0yLjE2NSAyLjE2Ny45NjkgMi4xNjcgMi4xNjUtLjk3IDIuMTY1LTIuMTY3IDIuMTY1em01LjE4IDBjLS4wNDEtNC4wMjktMy4zMTQtNy4yOTgtNy4zNDgtNy4zMzl2LTMuMjA3YzUuODE0LjA0MSAxMC41MTggNC43MzkgMTAuNTYxIDEwLjU0NmgtMy4yMTN6bTUuNDQxIDBjLS4wMjEtNy4wNjMtNS43MzYtMTIuNzYxLTEyLjc4OS0xMi43OTJ2LTMuMjA4YzguODMuMDMxIDE1Ljk4IDcuMTc5IDE2IDE2aC0zLjIxMXoiLz48L3N2Zz4="></a></div></div></div><div id="page-title"><h1 class="title plain">Improving Codable for enums with associated values</h1><h2 class="when">08 Dec 2017</h2><div id="tags"><div class="tag-container"><div class="tag"><a href="/tags/codable/index.html">Codable</a></div><div class="tag"><a href="/tags/enums/index.html">Enums</a></div></div></div><div class="divider"></div></div><div id="page-content"><p>With Swift 4 we received a new api to help automagically encode and decode types. By conforming to <code>Codable</code> (A protocol composed of <code>Encodable</code> and <code>Decodable</code>) we can convert types to and from different formats, such as json or property lists.</p><h2>Quick recap</h2><p>There are a number of types that already conform to <code>Codable</code> out-of-the-box. At the time of writing these are: <code>String</code>, <code>Int</code>, <code>Double</code>, <code>Date</code>, <code>Data</code> and <code>URL</code>. The nice part about <code>Codable</code> is, if your type is made up of <em>other</em> <code>Codable</code>s then you get <code>Codable</code> for free. So that means you can define types like:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">User</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">url</span><span class="none">: </span><span class="type">URL</span><span class="none">
}
</span></code></pre><p>and</p><pre><code class="language-swift"><span class="keyword">enum</span><span class="none"> </span><span class="identifier">AuthState</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">loggedIn</span><span class="none">
    </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">loggedOut</span><span class="none">
}
</span></code></pre><p>And <code>Codable</code> <em>just works</em> - no extra code is required.</p><p>You can store <code>AuthState</code> for example with something like:</p><pre><code class="language-swift"><span class="keyword">let</span><span class="none"> </span><span class="identifier">state</span><span class="none">: </span><span class="type">AuthState</span><span class="none"> = .</span><span class="identifier">loggedIn</span><span class="none">
</span><span class="keyword">let</span><span class="none"> </span><span class="identifier">data</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">JSONEncoder</span><span class="none">().</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">state</span><span class="none">)
</span><span class="identifier">data</span><span class="none">.</span><span class="identifier">write</span><span class="none">(</span><span class="identifier">to</span><span class="none">: </span><span class="identifier">configFile</span><span class="none">)
</span></code></pre><p>How great is that?!</p><h2>Limitations</h2><p>The enum is interesting. The reason this works is because we have given it a <code>RawValue</code> of <code>String</code>. Swift can use that to infer a <code>String</code> for each case and since <code>String</code> is <code>Codable</code> we get it for free, but what if we wanted to change the enum slightly?</p><pre><code class="language-swift"><span class="keyword">enum</span><span class="none"> </span><span class="identifier">AuthState</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">loggedIn</span><span class="none">(</span><span class="type">User</span><span class="none">)
    </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">loggedOut</span><span class="none">
}
</span></code></pre><p>We decide its better to store the logged in user with the logged in state and since <code>User</code> is <code>Codable</code> this should just work too right?</p><p>Unfortunately this isnâ€™t the case (no pun intended)â€¦ the enum is no longer <code>RawRepresentable</code> and since there is <em>no</em> <code>RawValue</code> anymore Swift doesnâ€™t know how to encode/decode each case.</p><h2>Manually implementing Codable</h2><p>To make this change work we will need to implement <code>Codable</code> ourselves. Lets start by creating the <code>CodingKey</code>s the enum will use to provide a unique key for each case:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">AuthState</span><span class="none"> {
    </span><span class="keyword">private</span><span class="none"> </span><span class="keyword">enum</span><span class="none"> </span><span class="identifier">CodingKeys</span><span class="none">: </span><span class="type">String</span><span class="none">, </span><span class="type">CodingKey</span><span class="none"> {
        </span><span class="keyword">case</span><span class="none"> </span><span class="identifier">loggedIn</span><span class="none">, </span><span class="identifier">loggedOut</span><span class="none">
    }
}
</span></code></pre><p>Next, lets implement the <code>Encodable</code> part:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">AuthState</span><span class="none"> {
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">to</span><span class="none"> </span><span class="identifier">encoder</span><span class="none">: </span><span class="type">Encoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">container</span><span class="none"> = </span><span class="identifier">encoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">CodingKeys</span><span class="none">.</span><span class="keyword">self</span><span class="none">)

        </span><span class="keyword">switch</span><span class="none"> </span><span class="keyword">self</span><span class="none"> {
        </span><span class="keyword">case</span><span class="none"> .</span><span class="identifier">loggedIn</span><span class="none">(</span><span class="keyword">let</span><span class="none"> </span><span class="identifier">user</span><span class="none">): </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">user</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedIn</span><span class="none">)
        </span><span class="keyword">case</span><span class="none"> .</span><span class="identifier">loggedOut</span><span class="none">:          </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">CodingKeys</span><span class="none">.</span><span class="identifier">loggedOut</span><span class="none">.</span><span class="identifier">stringValue</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedOut</span><span class="none">)
        }
    }
}
</span></code></pre><p>You can see the <code>Encodable</code> part benefits from exhaustive switching, we encode cases with an associated value using their <code>CodingKey</code> as the â€˜keyâ€™ and the associated value as the â€˜valueâ€™. For cases without an associated value we use the <code>CodingKey</code> as both the â€˜keyâ€™ and â€˜valueâ€™.</p><p>Finally lets look at the <code>Decodable</code> code:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">AuthState</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">: </span><span class="type">Decoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">container</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">CodingKeys</span><span class="none">.</span><span class="keyword">self</span><span class="none">)

        </span><span class="keyword">if</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">user</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">User</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedIn</span><span class="none">) {
            </span><span class="keyword">self</span><span class="none"> = .</span><span class="identifier">loggedIn</span><span class="none">(</span><span class="identifier">user</span><span class="none">)
        } </span><span class="keyword">else</span><span class="none"> </span><span class="keyword">if</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="keyword">_</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">String</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedOut</span><span class="none">) {
            </span><span class="keyword">self</span><span class="none"> = .</span><span class="identifier">loggedOut</span><span class="none">
        } </span><span class="keyword">else</span><span class="none"> {
            </span><span class="keyword">throw</span><span class="none"> </span><span class="identifier">DecodingError</span><span class="none">.</span><span class="identifier">valueNotFound</span><span class="none">(</span><span class="identifier">AuthState</span><span class="none">.</span><span class="keyword">self</span><span class="none">, .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">codingPath</span><span class="none">: </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">codingPath</span><span class="none">, </span><span class="identifier">debugDescription</span><span class="none">: </span><span class="literal">&quot;&quot;</span><span class="none">))
        }
    }
}
</span></code></pre><p>For <code>Decodable</code>  we unfortunately arenâ€™t able to leverage exhaustive switching. So we need to attempt to decode each case one by one. For cases with an associated value this means attempting to decode the associated value for the key. For cases without associated values we attempt to decode the <code>String</code> value. Finally if nothing succeeds we throw a <code>DecodingError</code>.</p><p>This is perfectly fine and will work as-is, so we <em>could</em> just leave it here and be done. While the <code>Encodable</code> code is about as concise as we can make it this <code>Decodable</code> code is a little wordy.</p><p>Let's look at how we might clean this up a little.</p><h2>Creating a reusable way to decode enums</h2><p>If we look at the current solution to decoding its essentially the same as iterating through all possible cases attempting to decode the required data for each case. It stops as soon as a something is decoded, if nothing was decoded we throw an error.</p><p>Lets build something that uses that pattern:</p><pre><code class="language-swift"><span class="keyword">typealias</span><span class="none"> </span><span class="identifier">Decode</span><span class="none">&lt;</span><span class="identifier">Result</span><span class="none">: </span><span class="type">Decodable</span><span class="none">, </span><span class="identifier">Key</span><span class="none">: </span><span class="type">CodingKey</span><span class="none">&gt; = (</span><span class="type">KeyedDecodingContainer</span><span class="none">&lt;</span><span class="type">Key</span><span class="none">&gt;) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">Result</span><span class="none">?

</span><span class="keyword">func</span><span class="none"> </span><span class="identifier">decode</span><span class="none">&lt;</span><span class="identifier">Result</span><span class="none">: </span><span class="type">Decodable</span><span class="none">, </span><span class="identifier">Key</span><span class="none">&gt;(</span><span class="identifier">using</span><span class="none"> </span><span class="identifier">container</span><span class="none">: </span><span class="type">KeyedDecodingContainer</span><span class="none">&lt;</span><span class="type">Key</span><span class="none">&gt;, </span><span class="identifier">cases</span><span class="none">: [</span><span class="type">Decode</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">, </span><span class="type">Key</span><span class="none">&gt;]) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">Result</span><span class="none"> {
    </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">result</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">cases</span><span class="none">.</span><span class="identifier">lazy</span><span class="none">.</span><span class="identifier">flatMap</span><span class="none">({ </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">$0</span><span class="none">(</span><span class="identifier">container</span><span class="none">) }).</span><span class="identifier">first</span><span class="none">
        </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">throw</span><span class="none"> </span><span class="identifier">DecodingError</span><span class="none">.</span><span class="identifier">valueNotFound</span><span class="none">(</span><span class="identifier">Result</span><span class="none">.</span><span class="keyword">self</span><span class="none">, .</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">codingPath</span><span class="none">: </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">codingPath</span><span class="none">, </span><span class="identifier">debugDescription</span><span class="none">: </span><span class="literal">&quot;&quot;</span><span class="none">)) }

    </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">result</span><span class="none">
}
</span></code></pre><p>This allows us to supply an array of closures, each one uses the container to attempt to decode the data for its specific case. Using this we end up with <code>Decodable</code> code that looks like this:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">AuthState</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">: </span><span class="type">Decoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">self</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">decode</span><span class="none">(</span><span class="identifier">using</span><span class="none">: </span><span class="identifier">decoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">CodingKeys</span><span class="none">.</span><span class="keyword">self</span><span class="none">), </span><span class="identifier">cases</span><span class="none">: [
            { </span><span class="identifier">container</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">User</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedIn</span><span class="none">) </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">return</span><span class="none"> </span><span class="keyword">nil</span><span class="none"> }
                </span><span class="keyword">return</span><span class="none"> .</span><span class="identifier">loggedIn</span><span class="none">(</span><span class="identifier">value</span><span class="none">)
            },
            { </span><span class="identifier">container</span><span class="none"> </span><span class="keyword">in</span><span class="none">
                </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="keyword">_</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">String</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: .</span><span class="identifier">loggedOut</span><span class="none">) </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">return</span><span class="none"> </span><span class="keyword">nil</span><span class="none"> }
                </span><span class="keyword">return</span><span class="none"> .</span><span class="identifier">loggedOut</span><span class="none">
            },
            ]
        )
    }
}
</span></code></pre><p>Now we have something that does the same thing as the original pattern, and while it now takes care of the error handling for us it doesnâ€™t really read any better (in fact you could argue its actually worse ðŸ˜­).</p><p>What we want to end up with is a function that fits our <code>Decode</code> signature. However because we need to provide more data we will need to create a curried function that <em>eventually</em> returns our <code>Decode</code> function.</p><p>The code we already have actually covers our two scenarios, so we can use them as the basis for our new curried functions.</p><h3>Without associated values</h3><p>Here is our function for dealing with cases without associated values. We are passing in the case we want, assuming decoding is successful, as well as the <code>CodingKey</code> it should be stored under.</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">Result</span><span class="none">: </span><span class="type">Decodable</span><span class="none">, </span><span class="identifier">Key</span><span class="none">: </span><span class="type">CodingKey</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">case</span><span class="none">: </span><span class="type">Result</span><span class="none">, </span><span class="identifier">for</span><span class="none"> </span><span class="identifier">key</span><span class="none">: </span><span class="type">Key</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">Decode</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">, </span><span class="type">Key</span><span class="none">&gt; {
    </span><span class="keyword">return</span><span class="none"> { </span><span class="identifier">container</span><span class="none"> </span><span class="keyword">in</span><span class="none">
        </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="keyword">_</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">String</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: </span><span class="identifier">key</span><span class="none">) </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">return</span><span class="none"> </span><span class="keyword">nil</span><span class="none"> }
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">`case`</span><span class="none">
    }
}
</span></code></pre><p>Now we can use the statement <code>value(AuthState.loggedOut, for: .loggedOut)</code> in place of the closure for this case.</p><h3>With associated values</h3><p>Handling cases with associated values lets us use one of Swifts many cool features.  Cases with associated values behave like constructor functions and can be referenced the same way. An example should make this clearer:</p><pre><code class="language-swift"><span class="comment">// notice we have omitted the associated value for this case</span><span class="none">
</span><span class="identifier">AuthState</span><span class="none">.</span><span class="identifier">loggedIn</span><span class="none"> </span><span class="comment">// (User) -&gt; AuthState</span><span class="none">
</span></code></pre><p>Well that is convenient, thats the exact function we need to infer all the extra details from the original closure!</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">value</span><span class="none">&lt;</span><span class="identifier">Result</span><span class="none">: </span><span class="type">Decodable</span><span class="none">, </span><span class="identifier">Key</span><span class="none">: </span><span class="type">CodingKey</span><span class="none">, </span><span class="identifier">T</span><span class="none">: </span><span class="type">Decodable</span><span class="none">&gt;(</span><span class="keyword">_</span><span class="none"> </span><span class="identifier">function</span><span class="none">: </span><span class="keyword">@escaping</span><span class="none"> (</span><span class="type">T</span><span class="none">) -&gt; </span><span class="type">Result</span><span class="none">, </span><span class="identifier">for</span><span class="none"> </span><span class="identifier">key</span><span class="none">: </span><span class="type">Key</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> -&gt; </span><span class="type">Decode</span><span class="none">&lt;</span><span class="type">Result</span><span class="none">, </span><span class="type">Key</span><span class="none">&gt; {
    </span><span class="keyword">return</span><span class="none"> { </span><span class="identifier">container</span><span class="none"> </span><span class="keyword">in</span><span class="none">
        </span><span class="keyword">guard</span><span class="none"> </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decodeIfPresent</span><span class="none">(</span><span class="identifier">T</span><span class="none">.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: </span><span class="identifier">key</span><span class="none">) </span><span class="keyword">else</span><span class="none"> { </span><span class="keyword">return</span><span class="none"> </span><span class="keyword">nil</span><span class="none"> }
        </span><span class="keyword">return</span><span class="none"> </span><span class="identifier">function</span><span class="none">(</span><span class="identifier">value</span><span class="none">)
    }
}
</span></code></pre><p>Now our associated value closure can be replaced with <code>value(AuthState.loggedIn, for: .loggedIn)</code>.</p><h3>Final Solution</h3><p>Putting it all together re can rewrite our <code>Decodable</code> code:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">AuthState</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">: </span><span class="type">Decoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">self</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">decode</span><span class="none">(</span><span class="identifier">using</span><span class="none">: </span><span class="identifier">decoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">CodingKeys</span><span class="none">.</span><span class="keyword">self</span><span class="none">), </span><span class="identifier">cases</span><span class="none">: [
            </span><span class="identifier">value</span><span class="none">(</span><span class="identifier">AuthState</span><span class="none">.</span><span class="identifier">loggedIn</span><span class="none">, </span><span class="identifier">for</span><span class="none">: .</span><span class="identifier">loggedIn</span><span class="none">),
            </span><span class="identifier">value</span><span class="none">(</span><span class="identifier">AuthState</span><span class="none">.</span><span class="identifier">loggedOut</span><span class="none">, </span><span class="identifier">for</span><span class="none">: .</span><span class="identifier">loggedOut</span><span class="none">),
            ]
        )
    }
}
</span></code></pre><p>I think that looks much nicer now.</p><h2>Caveats</h2><p>Itâ€™s worth noting that while this works great for local serialization it <em>may</em> not be in the format you need if you intend on sending this to a server. For instance our cases, when converted to json become:</p><p><code>.loggedIn(User(name: "Ian Keen", url: URL(string: "http://iankeen.tech/")!))</code> becomes:</p><pre><code>{"loggedIn":{"name":"Ian Keen","url":"http://iankeen.tech/"}}
</code></pre><p><code>.loggedOut</code> becomes:</p><pre><code>{"loggedOut":"loggedOut"}
</code></pre><p>You may need to tweak the format a little to suit your server api requirements.</p><h2>Wrapping up</h2><p>Its a shame this doesnâ€™t fit into the automagical <code>Codable</code> bucket, hopefully it is something we will get in the future. For now I think this is a decent solution for keeping this cleaner.</p><p>To see the full code checkout <a href="/Resources/improving_codable_for_enums_with_associated_values/improving-codable-for-enums-with-associated-values.zip">this</a> playground.</p></div><div id="page-footer"><div class="divider"></div><p>(c) Ian Keen</p></div></body></html>