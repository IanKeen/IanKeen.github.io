<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content=""><meta viewport="width=device-width, initial-scale=1"><meta name="author" content="Ian Keen"><meta og:site_name="Better Codable models through composition"><meta og:title="Better Codable models through composition"><meta og:description=""><meta og:url="https://iankeen.tech"><meta twitter:card="summary"><meta twitter:site="@IanKay"><meta twitter:creator="@IanKay"><meta twitter:title="Better Codable models through composition"><meta twitter:description=""><title>devbits: random development bits by Ian Keen</title><link rel="stylesheet" href="/Resources/style.css"><link rel="stylesheet" href="/Resources/swift.css"><link rel="shortcut icon" href="/Resources/favicon.ico"></head><body><div id="page-header"><a href="/"><div id="logo" class="wiggle"><p>devbits</p></div></a><div id="links"><div id="me"><a href="/workwithme/index.html">work with me</a><a href="/about/index.html">about</a></div><div id="social"><a href="https://www.twitter.com/IanKay"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tLjEzOSA5LjIzN2MuMjA5IDQuNjE3LTMuMjM0IDkuNzY1LTkuMzMgOS43NjUtMS44NTQgMC0zLjU3OS0uNTQzLTUuMDMyLTEuNDc1IDEuNzQyLjIwNSAzLjQ4LS4yNzggNC44Ni0xLjM1OS0xLjQzNy0uMDI3LTIuNjQ5LS45NzYtMy4wNjYtMi4yOC41MTUuMDk4IDEuMDIxLjA2OSAxLjQ4Mi0uMDU2LTEuNTc5LS4zMTctMi42NjgtMS43MzktMi42MzMtMy4yNi40NDIuMjQ2Ljk0OS4zOTQgMS40ODYuNDExLTEuNDYxLS45NzctMS44NzUtMi45MDctMS4wMTYtNC4zODMgMS42MTkgMS45ODYgNC4wMzggMy4yOTMgNi43NjYgMy40My0uNDc5LTIuMDUzIDEuMDgtNC4wMyAzLjE5OS00LjAzLjk0MyAwIDEuNzk3LjM5OCAyLjM5NSAxLjAzNy43NDgtLjE0NyAxLjQ1MS0uNDIgMi4wODYtLjc5Ni0uMjQ2Ljc2Ny0uNzY2IDEuNDEtMS40NDMgMS44MTYuNjY0LS4wOCAxLjI5Ny0uMjU2IDEuODg1LS41MTctLjQzOS42NTYtLjk5NiAxLjIzNC0xLjYzOSAxLjY5N3oiLz48L3N2Zz4="></a><a href="https://www.github.com/IanKeen"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tNC40NjYgMTkuNTljLS40MDUuMDc4LS41MzQtLjE3MS0uNTM0LS4zODR2LTIuMTk1YzAtLjc0Ny0uMjYyLTEuMjMzLS41NS0xLjQ4MSAxLjc4Mi0uMTk4IDMuNjU0LS44NzUgMy42NTQtMy45NDcgMC0uODc0LS4zMTItMS41ODgtLjgyMy0yLjE0Ny4wODItLjIwMi4zNTYtMS4wMTYtLjA3OS0yLjExNyAwIDAtLjY3MS0uMjE1LTIuMTk4LjgyLS42NC0uMTgtMS4zMjQtLjI2Ny0yLjAwNC0uMjcxLS42OC4wMDMtMS4zNjQuMDkxLTIuMDAzLjI2OS0xLjUyOC0xLjAzNS0yLjItLjgyLTIuMi0uODItLjQzNCAxLjEwMi0uMTYgMS45MTUtLjA3NyAyLjExOC0uNTEyLjU2LS44MjQgMS4yNzMtLjgyNCAyLjE0NyAwIDMuMDY0IDEuODY3IDMuNzUxIDMuNjQ1IDMuOTU0LS4yMjkuMi0uNDM2LjU1Mi0uNTA4IDEuMDctLjQ1Ny4yMDQtMS42MTQuNTU3LTIuMzI4LS42NjYgMCAwLS40MjMtLjc2OC0xLjIyNy0uODI1IDAgMC0uNzgtLjAxLS4wNTUuNDg3IDAgMCAuNTI1LjI0Ni44ODkgMS4xNyAwIDAgLjQ2MyAxLjQyOCAyLjY4OC45NDR2MS40ODljMCAuMjExLS4xMjkuNDU5LS41MjguMzg1LTMuMTgtMS4wNTctNS40NzItNC4wNTYtNS40NzItNy41OSAwLTQuNDE5IDMuNTgyLTggOC04czggMy41ODEgOCA4YzAgMy41MzMtMi4yODkgNi41MzEtNS40NjYgNy41OXoiLz48L3N2Zz4="></a><a href="https://iankeen.tech/atom.xml"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgMGgtMTRjLTIuNzYxIDAtNSAyLjIzOS01IDV2MTRjMCAyLjc2MSAyLjIzOSA1IDUgNWgxNGMyLjc2MiAwIDUtMi4yMzkgNS01di0xNGMwLTIuNzYxLTIuMjM4LTUtNS01em0tMTIuODMyIDIwYy0xLjE5NyAwLTIuMTY4LS45NjktMi4xNjgtMi4xNjVzLjk3MS0yLjE2NSAyLjE2OC0yLjE2NSAyLjE2Ny45NjkgMi4xNjcgMi4xNjUtLjk3IDIuMTY1LTIuMTY3IDIuMTY1em01LjE4IDBjLS4wNDEtNC4wMjktMy4zMTQtNy4yOTgtNy4zNDgtNy4zMzl2LTMuMjA3YzUuODE0LjA0MSAxMC41MTggNC43MzkgMTAuNTYxIDEwLjU0NmgtMy4yMTN6bTUuNDQxIDBjLS4wMjEtNy4wNjMtNS43MzYtMTIuNzYxLTEyLjc4OS0xMi43OTJ2LTMuMjA4YzguODMuMDMxIDE1Ljk4IDcuMTc5IDE2IDE2aC0zLjIxMXoiLz48L3N2Zz4="></a></div></div></div><div id="page-title"><h1 class="title plain">Better Codable models through composition</h1><h2 class="when">01 Mar 2019</h2><div id="tags"><div class="tag-container"><div class="tag"><a href="/tags/codable/index.html">Codable</a></div></div></div><div class="divider"></div></div><div id="page-content"><p>Imagine we want to build an app to track books. The API we are building against provides JSON for authors and book which looks like:</p><pre><code>{
    "identifier": "A13424B6",
    "name": "Robert C. Martin"
}

{
    "identifier": "A161F15C",
    "title": "Clean Code",
    "authorIdentifier": "A13424B6"
}
</code></pre><p>Swifts <code>Codable</code> features enable us to quickly create matching models:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Author</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">identifier</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
}

</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Book</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">identifier</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">title</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">authorIdentifier</span><span class="none">: </span><span class="type">String</span><span class="none">
}
</span></code></pre><p>Thanks to <code>Codable</code> this is all we have to do to get JSON mapping to type-safe models for free!</p><p>There are, however, a couple of subtle issues that could cause problems as we progress. The <code>identifier</code>s are defined as <code>String</code>s. This isn't <em>wrong</em> but it could lead to a scenario like:</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">allBooks</span><span class="none">(</span><span class="identifier">by</span><span class="none"> </span><span class="identifier">authorIdentifier</span><span class="none">: </span><span class="type">String</span><span class="none">) -&gt; [</span><span class="type">Book</span><span class="none">] {
    </span><span class="comment">//.. lookup books by id</span><span class="none">
}

</span><span class="keyword">let</span><span class="none"> </span><span class="identifier">bobsBooks</span><span class="none"> = </span><span class="identifier">allBooks</span><span class="none">(</span><span class="identifier">by</span><span class="none">: </span><span class="literal">&quot;Robert C. Martin&quot;</span><span class="none">) </span><span class="comment">// oops!</span><span class="none">
</span></code></pre><p>This would compile and although the call-site <em>seems</em> to read correctly it would never return anything because the function expects an authors identifier not their name. Let's look at a type we can use instead of <code>String</code> to improve the type-safety here.</p><h2>Identifier<T></h2><p>We can't change the fact that the server is sending us <code>String</code>s but we can change how those strings are represented locally using a wrapper and phantom-types.</p><p>Usually when we define a generic type like <code>Identifier<T></code> we also use that <code>T</code> elsewhere in the type, something like <code>let value: T</code>. However when the <code>T</code> is only present as part of the declaration it is called a phantom type.</p><p>What's the point then? Why make something generic if we aren't using the type? Well we actually <em>are</em> using the type, just not in the usual way. Let's take a look:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Identifier</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt; {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="type">String</span><span class="none">
}
</span></code></pre><p>Updating our models to use this new type, they become:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Author</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">identifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">Author</span><span class="none">&gt;
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
}

</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Book</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">identifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">Book</span><span class="none">&gt;
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">title</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">authorIdentifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">Author</span><span class="none">&gt;
}
</span></code></pre><p>and our function now becomes:</p><pre><code class="language-swift"><span class="keyword">func</span><span class="none"> </span><span class="identifier">allBooks</span><span class="none">(</span><span class="identifier">by</span><span class="none"> </span><span class="identifier">authorIdentifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">Author</span><span class="none">&gt;) -&gt; [</span><span class="type">Book</span><span class="none">] {
    </span><span class="comment">//.. lookup books by authorIdentifier.value</span><span class="none">
}

</span><span class="keyword">let</span><span class="none"> </span><span class="identifier">bobsBooks</span><span class="none"> = </span><span class="identifier">allBooks</span><span class="none">(</span><span class="identifier">by</span><span class="none">: </span><span class="literal">&quot;Robert C. Martin&quot;</span><span class="none">) </span><span class="comment">// failure!! (the good kind)</span><span class="none">
</span></code></pre><p>We have now made it impossible to incorrectly pass a <code>String</code>. We <em>must</em> provide an <code>Identifier<Author></code> instead otherwise it will not compile even though they are all still <code>String</code>s underneath.</p><p>This is what makes phantom types so useful. In this instance we are adding type-safety to an ordinary <code>String</code> using a generic placeholder. We can now use <code>Identifier<T></code> for not only our <code>Book</code> and <code>Author</code> models but any other model with an identifier as well.</p><h2>Codable support</h2><p>There is a new problem our new <code>Identifier<T></code>  has introduced. <code>Codable</code>, by default, uses the same structure as the type. This means the JSON representation of an identifier would be:</p><pre><code>{"value": "A13424B6"}
</code></pre><p>This is wrong, we still want the JSON representation to be a <code>String</code> so it works seamlessly with our API. Let's fix the <code>Codable</code> behaviour:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">Identifier</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">: </span><span class="type">Decoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">value</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">String</span><span class="none">(</span><span class="identifier">from</span><span class="none">: </span><span class="identifier">decoder</span><span class="none">)
    }
    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">to</span><span class="none"> </span><span class="identifier">encoder</span><span class="none">: </span><span class="type">Encoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">value</span><span class="none">.</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">to</span><span class="none">: </span><span class="identifier">encoder</span><span class="none">)
    }
}
</span></code></pre><p>Now when we convert between the model and JSON it will be a regular <code>String</code> rather than a nested object.</p><h2>Adding new data to the API</h2><p>Listing books and authors is working really well. Now it's time to allow our users to submit new entries. The only problem is our API is responsible for determining the identifiers of new data so we want to send JSON containing everything <em>but</em> the object identifier.</p><p>There are different ways we could tackle this:</p><ul><li>We could maintain a separate model that excludes the <code>identifier</code>. This is tedious and fragile but perhaps we could leverage a codegen solution to help? This is a big dependency to add if you aren't already using one though.</li><li>We could provide a dummy identifier and remove it from the JSON before sending it to our API. This isn't very nice though, using dummy values in production code seems like something just begging to break and/or corrupt things.</li></ul><p>Since we are creating new types today let's look at another one that can be used to solve this problem.</p><h2>Identified<T></h2><p>What we need is a way to define two versions of our models. One with an <code>identifier</code> when data is sent down and one without an <code>identifier</code> when we send data up.</p><p>We can't use the type system to <em>remove</em> properties... but we can use it to <em>add</em> them.</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Identified</span><span class="none">&lt;</span><span class="identifier">T</span><span class="none">&gt; {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">identifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">T</span><span class="none">&gt;
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">value</span><span class="none">: </span><span class="type">T</span><span class="none">
}
</span></code></pre><p>Using this type we can remove the <code>identifier</code> property from our models.</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Author</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">name</span><span class="none">: </span><span class="type">String</span><span class="none">
}

</span><span class="keyword">struct</span><span class="none"> </span><span class="identifier">Book</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">title</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">authorIdentifier</span><span class="none">: </span><span class="type">Identifier</span><span class="none">&lt;</span><span class="type">Author</span><span class="none">&gt;
}
</span></code></pre><p>We can then define the two version of a model we need. When we are receiving books from the API we can use <code>Identified<Book></code> for each instance. When we want to add a new book we simply use <code>Book</code> as-is.</p><p>Having a type like <code>Identified<T></code> gives us the flexibility we want without needing to maintain parallel models or hack out unwanted values before sending data.</p><h2>Codable support</h2><p>As with <code>Identifier<T></code> the default <code>Codable</code> behaviour for <code>Identified<T></code> would result in the wrong JSON:</p><pre><code>{
    "identifier": "A13424B6",
    "value": {
        "name": "Robert C. Martin"
    }
}
</code></pre><p>We need to fix the <code>Codable</code> behaviour so everything is still flattened when in it's JSON form:</p><pre><code class="language-swift"><span class="keyword">extension</span><span class="none"> </span><span class="type">Identified</span><span class="none">: </span><span class="type">Codable</span><span class="none"> </span><span class="keyword">where</span><span class="none"> </span><span class="type">T</span><span class="none">: </span><span class="type">Codable</span><span class="none"> {
    </span><span class="keyword">init</span><span class="none">(</span><span class="identifier">from</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">: </span><span class="type">Decoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">let</span><span class="none"> </span><span class="identifier">container</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">decoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">AnyCodingKey</span><span class="none">.</span><span class="keyword">self</span><span class="none">)

        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">identifier</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">decode</span><span class="none">(</span><span class="identifier">Identifier</span><span class="none">&lt;</span><span class="type">T</span><span class="none">&gt;.</span><span class="keyword">self</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: </span><span class="identifier">AnyCodingKey</span><span class="none">(</span><span class="identifier">stringValue</span><span class="none">: </span><span class="literal">&quot;identifier&quot;</span><span class="none">)!)
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">value</span><span class="none"> = </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">T</span><span class="none">.</span><span class="identifier">init</span><span class="none">(</span><span class="identifier">from</span><span class="none">: </span><span class="identifier">decoder</span><span class="none">)
    }

    </span><span class="keyword">func</span><span class="none"> </span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">to</span><span class="none"> </span><span class="identifier">encoder</span><span class="none">: </span><span class="type">Encoder</span><span class="none">) </span><span class="keyword">throws</span><span class="none"> {
        </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">container</span><span class="none"> = </span><span class="identifier">encoder</span><span class="none">.</span><span class="identifier">container</span><span class="none">(</span><span class="identifier">keyedBy</span><span class="none">: </span><span class="identifier">AnyCodingKey</span><span class="none">.</span><span class="keyword">self</span><span class="none">)

        </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">container</span><span class="none">.</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">identifier</span><span class="none">, </span><span class="identifier">forKey</span><span class="none">: </span><span class="identifier">AnyCodingKey</span><span class="none">(</span><span class="identifier">stringValue</span><span class="none">: </span><span class="literal">&quot;identifier&quot;</span><span class="none">)!)
        </span><span class="keyword">try</span><span class="none"> </span><span class="identifier">value</span><span class="none">.</span><span class="identifier">encode</span><span class="none">(</span><span class="identifier">to</span><span class="none">: </span><span class="identifier">encoder</span><span class="none">)
    }
}
</span></code></pre><p>The <code>AnyCodingKey</code> type is used to allow us to dynamically decode certain parts of the data without needing all new types:</p><pre><code class="language-swift"><span class="keyword">struct</span><span class="none"> </span><span class="identifier">AnyCodingKey</span><span class="none">: </span><span class="type">CodingKey</span><span class="none"> {
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">stringValue</span><span class="none">: </span><span class="type">String</span><span class="none">
    </span><span class="keyword">var</span><span class="none"> </span><span class="identifier">intValue</span><span class="none">: </span><span class="type">Int</span><span class="none">?

    </span><span class="keyword">init</span><span class="none">?(</span><span class="identifier">intValue</span><span class="none">: </span><span class="type">Int</span><span class="none">) {
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">intValue</span><span class="none"> = </span><span class="identifier">intValue</span><span class="none">
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">stringValue</span><span class="none"> = </span><span class="literal">&quot;</span><span class="none">\</span><span class="none">(</span><span class="identifier">intValue</span><span class="none">)</span><span class="literal">&quot;</span><span class="none">
    }
    </span><span class="keyword">init</span><span class="none">?(</span><span class="identifier">stringValue</span><span class="none">: </span><span class="type">String</span><span class="none">) {
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">intValue</span><span class="none"> = </span><span class="keyword">nil</span><span class="none">
        </span><span class="keyword">self</span><span class="none">.</span><span class="identifier">stringValue</span><span class="none"> = </span><span class="identifier">stringValue</span><span class="none">
    }
}
</span></code></pre><h2>The end!</h2><p>There are many ways to skin a cat, but hopefully this has shown a couple of interesting way to solve some common problems using wrapper types and some pretty nifty Swift features.</p><p>There are a lot of additions that can be made to improve the ergonomics of these types also such as:</p><ul><li><code>ExpressibleBy*</code> conformance</li><li>Supporting values other than <code>String</code></li></ul><p>But I'll leave these as an exercise for the reader 🤘</p><p>You can grab a playground with all the code <a href="/Resources/better_codable_models_through_composition/CodableComposition.zip">here</a></p><p>If you have any feedback feel free to reach out!</p></div><div id="page-footer"><div class="divider"></div><p>(c) Ian Keen</p></div></body></html>